<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'llvm' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/LLVM/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>'llvm' Dialect</h1><p>This dialect maps
<a href=https://llvm.org/docs/LangRef.html>LLVM IR</a>
into MLIR by
defining the corresponding operations and types. LLVM IR metadata is usually
represented as MLIR attributes, which offer additional structure verification.</p><p>We use &ldquo;LLVM IR&rdquo; to designate the
<a href=https://llvm.org/docs/LangRef.html>intermediate representation of LLVM</a>
and
&ldquo;LLVM <em>dialect</em>&rdquo; or &ldquo;LLVM IR <em>dialect</em>&rdquo; to refer to this MLIR dialect.</p><p>Unless explicitly stated otherwise, the semantics of the LLVM dialect operations
must correspond to the semantics of LLVM IR instructions and any divergence is
considered a bug. The dialect also contains auxiliary operations that smoothen
the differences in the IR structure, e.g., MLIR does not have <code>phi</code> operations
and LLVM IR does not have a <code>constant</code> operation. These auxiliary operations are
systematically prefixed with <code>mlir</code>, e.g. <code>llvm.mlir.constant</code> where <code>llvm.</code> is
the dialect namespace prefix.</p><p><nav id=TableOfContents><ul><li><a href=#dependency-on-llvm-ir>Dependency on LLVM IR</a></li><li><a href=#module-structure>Module Structure</a><ul><li><a href=#data-layout-and-triple>Data Layout and Triple</a></li><li><a href=#functions>Functions</a></li><li><a href=#phi-nodes-and-block-arguments>PHI Nodes and Block Arguments</a></li><li><a href=#context-level-values>Context-Level Values</a></li><li><a href=#globals>Globals</a></li><li><a href=#linkage>Linkage</a></li><li><a href=#attribute-pass-through>Attribute Pass-Through</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#simple-types>Simple Types</a></li><li><a href=#parametric-types>Parametric Types</a></li><li><a href=#structure-types>Structure Types</a></li><li><a href=#unsupported-types>Unsupported Types</a></li></ul></li><li><a href=#operations>Operations</a><ul><li><a href=#llvmashr-mlirllvmashrop>llvm.ashr (::mlir::LLVM::AShrOp)</a></li><li><a href=#llvmadd-mlirllvmaddop>llvm.add (::mlir::LLVM::AddOp)</a></li><li><a href=#llvmaddrspacecast-mlirllvmaddrspacecastop>llvm.addrspacecast (::mlir::LLVM::AddrSpaceCastOp)</a></li><li><a href=#llvmmliraddressof-mlirllvmaddressofop>llvm.mlir.addressof (::mlir::LLVM::AddressOfOp)</a></li><li><a href=#llvmalloca-mlirllvmallocaop>llvm.alloca (::mlir::LLVM::AllocaOp)</a></li><li><a href=#llvmand-mlirllvmandop>llvm.and (::mlir::LLVM::AndOp)</a></li><li><a href=#llvmintrassume-mlirllvmassumeop>llvm.intr.assume (::mlir::LLVM::AssumeOp)</a></li><li><a href=#llvmcmpxchg-mlirllvmatomiccmpxchgop>llvm.cmpxchg (::mlir::LLVM::AtomicCmpXchgOp)</a></li><li><a href=#llvmatomicrmw-mlirllvmatomicrmwop>llvm.atomicrmw (::mlir::LLVM::AtomicRMWOp)</a></li><li><a href=#llvmintrbitreverse-mlirllvmbitreverseop>llvm.intr.bitreverse (::mlir::LLVM::BitReverseOp)</a></li><li><a href=#llvmbitcast-mlirllvmbitcastop>llvm.bitcast (::mlir::LLVM::BitcastOp)</a></li><li><a href=#llvmbr-mlirllvmbrop>llvm.br (::mlir::LLVM::BrOp)</a></li><li><a href=#llvmcall-mlirllvmcallop>llvm.call (::mlir::LLVM::CallOp)</a></li><li><a href=#llvmcond_br-mlirllvmcondbrop>llvm.cond_br (::mlir::LLVM::CondBrOp)</a></li><li><a href=#llvmmlirconstant-mlirllvmconstantop>llvm.mlir.constant (::mlir::LLVM::ConstantOp)</a></li><li><a href=#llvmintrcopysign-mlirllvmcopysignop>llvm.intr.copysign (::mlir::LLVM::CopySignOp)</a></li><li><a href=#llvmintrcos-mlirllvmcosop>llvm.intr.cos (::mlir::LLVM::CosOp)</a></li><li><a href=#llvmintrctpop-mlirllvmctpopop>llvm.intr.ctpop (::mlir::LLVM::CtPopOp)</a></li><li><a href=#llvmmlircast-mlirllvmdialectcastop>llvm.mlir.cast (::mlir::LLVM::DialectCastOp)</a></li><li><a href=#llvmintrexp2-mlirllvmexp2op>llvm.intr.exp2 (::mlir::LLVM::Exp2Op)</a></li><li><a href=#llvmintrexp-mlirllvmexpop>llvm.intr.exp (::mlir::LLVM::ExpOp)</a></li><li><a href=#llvmextractelement-mlirllvmextractelementop>llvm.extractelement (::mlir::LLVM::ExtractElementOp)</a></li><li><a href=#llvmextractvalue-mlirllvmextractvalueop>llvm.extractvalue (::mlir::LLVM::ExtractValueOp)</a></li><li><a href=#llvmintrfabs-mlirllvmfabsop>llvm.intr.fabs (::mlir::LLVM::FAbsOp)</a></li><li><a href=#llvmfadd-mlirllvmfaddop>llvm.fadd (::mlir::LLVM::FAddOp)</a></li><li><a href=#llvmintrceil-mlirllvmfceilop>llvm.intr.ceil (::mlir::LLVM::FCeilOp)</a></li><li><a href=#llvmfcmp-mlirllvmfcmpop>llvm.fcmp (::mlir::LLVM::FCmpOp)</a></li><li><a href=#llvmfdiv-mlirllvmfdivop>llvm.fdiv (::mlir::LLVM::FDivOp)</a></li><li><a href=#llvmintrfloor-mlirllvmffloorop>llvm.intr.floor (::mlir::LLVM::FFloorOp)</a></li><li><a href=#llvmintrfma-mlirllvmfmaop>llvm.intr.fma (::mlir::LLVM::FMAOp)</a></li><li><a href=#llvmintrfmuladd-mlirllvmfmuladdop>llvm.intr.fmuladd (::mlir::LLVM::FMulAddOp)</a></li><li><a href=#llvmfmul-mlirllvmfmulop>llvm.fmul (::mlir::LLVM::FMulOp)</a></li><li><a href=#llvmfneg-mlirllvmfnegop>llvm.fneg (::mlir::LLVM::FNegOp)</a></li><li><a href=#llvmfpext-mlirllvmfpextop>llvm.fpext (::mlir::LLVM::FPExtOp)</a></li><li><a href=#llvmfptosi-mlirllvmfptosiop>llvm.fptosi (::mlir::LLVM::FPToSIOp)</a></li><li><a href=#llvmfptoui-mlirllvmfptouiop>llvm.fptoui (::mlir::LLVM::FPToUIOp)</a></li><li><a href=#llvmfptrunc-mlirllvmfptruncop>llvm.fptrunc (::mlir::LLVM::FPTruncOp)</a></li><li><a href=#llvmfrem-mlirllvmfremop>llvm.frem (::mlir::LLVM::FRemOp)</a></li><li><a href=#llvmfsub-mlirllvmfsubop>llvm.fsub (::mlir::LLVM::FSubOp)</a></li><li><a href=#llvmfence-mlirllvmfenceop>llvm.fence (::mlir::LLVM::FenceOp)</a></li><li><a href=#llvmfreeze-mlirllvmfreezeop>llvm.freeze (::mlir::LLVM::FreezeOp)</a></li><li><a href=#llvmgetelementptr-mlirllvmgepop>llvm.getelementptr (::mlir::LLVM::GEPOp)</a></li><li><a href=#llvmintrgetactivelanemask-mlirllvmgetactivelanemaskop>llvm.intr.get.active.lane.mask (::mlir::LLVM::GetActiveLaneMaskOp)</a></li><li><a href=#llvmmlirglobal-mlirllvmglobalop>llvm.mlir.global (::mlir::LLVM::GlobalOp)</a></li><li><a href=#llvmicmp-mlirllvmicmpop>llvm.icmp (::mlir::LLVM::ICmpOp)</a></li><li><a href=#llvminline_asm-mlirllvminlineasmop>llvm.inline_asm (::mlir::LLVM::InlineAsmOp)</a></li><li><a href=#llvminsertelement-mlirllvminsertelementop>llvm.insertelement (::mlir::LLVM::InsertElementOp)</a></li><li><a href=#llvminsertvalue-mlirllvminsertvalueop>llvm.insertvalue (::mlir::LLVM::InsertValueOp)</a></li><li><a href=#llvminttoptr-mlirllvminttoptrop>llvm.inttoptr (::mlir::LLVM::IntToPtrOp)</a></li><li><a href=#llvminvoke-mlirllvminvokeop>llvm.invoke (::mlir::LLVM::InvokeOp)</a></li><li><a href=#llvmfunc-mlirllvmllvmfuncop>llvm.func (::mlir::LLVM::LLVMFuncOp)</a></li><li><a href=#llvmlshr-mlirllvmlshrop>llvm.lshr (::mlir::LLVM::LShrOp)</a></li><li><a href=#llvmlandingpad-mlirllvmlandingpadop>llvm.landingpad (::mlir::LLVM::LandingpadOp)</a></li><li><a href=#llvmload-mlirllvmloadop>llvm.load (::mlir::LLVM::LoadOp)</a></li><li><a href=#llvmintrlog10-mlirllvmlog10op>llvm.intr.log10 (::mlir::LLVM::Log10Op)</a></li><li><a href=#llvmintrlog2-mlirllvmlog2op>llvm.intr.log2 (::mlir::LLVM::Log2Op)</a></li><li><a href=#llvmintrlog-mlirllvmlogop>llvm.intr.log (::mlir::LLVM::LogOp)</a></li><li><a href=#llvmintrmaskedload-mlirllvmmaskedloadop>llvm.intr.masked.load (::mlir::LLVM::MaskedLoadOp)</a></li><li><a href=#llvmintrmaskedstore-mlirllvmmaskedstoreop>llvm.intr.masked.store (::mlir::LLVM::MaskedStoreOp)</a></li><li><a href=#llvmintrmatrixcolumnmajorload-mlirllvmmatrixcolumnmajorloadop>llvm.intr.matrix.column.major.load (::mlir::LLVM::MatrixColumnMajorLoadOp)</a></li><li><a href=#llvmintrmatrixcolumnmajorstore-mlirllvmmatrixcolumnmajorstoreop>llvm.intr.matrix.column.major.store (::mlir::LLVM::MatrixColumnMajorStoreOp)</a></li><li><a href=#llvmintrmatrixmultiply-mlirllvmmatrixmultiplyop>llvm.intr.matrix.multiply (::mlir::LLVM::MatrixMultiplyOp)</a></li><li><a href=#llvmintrmatrixtranspose-mlirllvmmatrixtransposeop>llvm.intr.matrix.transpose (::mlir::LLVM::MatrixTransposeOp)</a></li><li><a href=#llvmintrmaxnum-mlirllvmmaxnumop>llvm.intr.maxnum (::mlir::LLVM::MaxNumOp)</a></li><li><a href=#llvmintrmemcpyinline-mlirllvmmemcpyinlineop>llvm.intr.memcpy.inline (::mlir::LLVM::MemcpyInlineOp)</a></li><li><a href=#llvmintrmemcpy-mlirllvmmemcpyop>llvm.intr.memcpy (::mlir::LLVM::MemcpyOp)</a></li><li><a href=#llvmintrminnum-mlirllvmminnumop>llvm.intr.minnum (::mlir::LLVM::MinNumOp)</a></li><li><a href=#llvmmul-mlirllvmmulop>llvm.mul (::mlir::LLVM::MulOp)</a></li><li><a href=#llvmmlirnull-mlirllvmnullop>llvm.mlir.null (::mlir::LLVM::NullOp)</a></li><li><a href=#llvmor-mlirllvmorop>llvm.or (::mlir::LLVM::OrOp)</a></li><li><a href=#llvmintrpow-mlirllvmpowop>llvm.intr.pow (::mlir::LLVM::PowOp)</a></li><li><a href=#llvmintrprefetch-mlirllvmprefetch>llvm.intr.prefetch (::mlir::LLVM::Prefetch)</a></li><li><a href=#llvmptrtoint-mlirllvmptrtointop>llvm.ptrtoint (::mlir::LLVM::PtrToIntOp)</a></li><li><a href=#llvmresume-mlirllvmresumeop>llvm.resume (::mlir::LLVM::ResumeOp)</a></li><li><a href=#llvmreturn-mlirllvmreturnop>llvm.return (::mlir::LLVM::ReturnOp)</a></li><li><a href=#llvmintrsaddwithoverflow-mlirllvmsaddwithoverflowop>llvm.intr.sadd.with.overflow (::mlir::LLVM::SAddWithOverflowOp)</a></li><li><a href=#llvmsdiv-mlirllvmsdivop>llvm.sdiv (::mlir::LLVM::SDivOp)</a></li><li><a href=#llvmsext-mlirllvmsextop>llvm.sext (::mlir::LLVM::SExtOp)</a></li><li><a href=#llvmsitofp-mlirllvmsitofpop>llvm.sitofp (::mlir::LLVM::SIToFPOp)</a></li><li><a href=#llvmintrsmax-mlirllvmsmaxop>llvm.intr.smax (::mlir::LLVM::SMaxOp)</a></li><li><a href=#llvmintrsmin-mlirllvmsminop>llvm.intr.smin (::mlir::LLVM::SMinOp)</a></li><li><a href=#llvmintrsmulwithoverflow-mlirllvmsmulwithoverflowop>llvm.intr.smul.with.overflow (::mlir::LLVM::SMulWithOverflowOp)</a></li><li><a href=#llvmsrem-mlirllvmsremop>llvm.srem (::mlir::LLVM::SRemOp)</a></li><li><a href=#llvmintrssubwithoverflow-mlirllvmssubwithoverflowop>llvm.intr.ssub.with.overflow (::mlir::LLVM::SSubWithOverflowOp)</a></li><li><a href=#llvmselect-mlirllvmselectop>llvm.select (::mlir::LLVM::SelectOp)</a></li><li><a href=#llvmshl-mlirllvmshlop>llvm.shl (::mlir::LLVM::ShlOp)</a></li><li><a href=#llvmshufflevector-mlirllvmshufflevectorop>llvm.shufflevector (::mlir::LLVM::ShuffleVectorOp)</a></li><li><a href=#llvmintrsin-mlirllvmsinop>llvm.intr.sin (::mlir::LLVM::SinOp)</a></li><li><a href=#llvmintrsqrt-mlirllvmsqrtop>llvm.intr.sqrt (::mlir::LLVM::SqrtOp)</a></li><li><a href=#llvmstore-mlirllvmstoreop>llvm.store (::mlir::LLVM::StoreOp)</a></li><li><a href=#llvmsub-mlirllvmsubop>llvm.sub (::mlir::LLVM::SubOp)</a></li><li><a href=#llvmswitch-mlirllvmswitchop>llvm.switch (::mlir::LLVM::SwitchOp)</a></li><li><a href=#llvmtrunc-mlirllvmtruncop>llvm.trunc (::mlir::LLVM::TruncOp)</a></li><li><a href=#llvmintruaddwithoverflow-mlirllvmuaddwithoverflowop>llvm.intr.uadd.with.overflow (::mlir::LLVM::UAddWithOverflowOp)</a></li><li><a href=#llvmudiv-mlirllvmudivop>llvm.udiv (::mlir::LLVM::UDivOp)</a></li><li><a href=#llvmuitofp-mlirllvmuitofpop>llvm.uitofp (::mlir::LLVM::UIToFPOp)</a></li><li><a href=#llvmintrumulwithoverflow-mlirllvmumulwithoverflowop>llvm.intr.umul.with.overflow (::mlir::LLVM::UMulWithOverflowOp)</a></li><li><a href=#llvmurem-mlirllvmuremop>llvm.urem (::mlir::LLVM::URemOp)</a></li><li><a href=#llvmintrusubwithoverflow-mlirllvmusubwithoverflowop>llvm.intr.usub.with.overflow (::mlir::LLVM::USubWithOverflowOp)</a></li><li><a href=#llvmmlirundef-mlirllvmundefop>llvm.mlir.undef (::mlir::LLVM::UndefOp)</a></li><li><a href=#llvmunreachable-mlirllvmunreachableop>llvm.unreachable (::mlir::LLVM::UnreachableOp)</a></li><li><a href=#llvmxor-mlirllvmxorop>llvm.xor (::mlir::LLVM::XOrOp)</a></li><li><a href=#llvmzext-mlirllvmzextop>llvm.zext (::mlir::LLVM::ZExtOp)</a></li><li><a href=#llvmintrmaskedcompressstore-mlirllvmmasked_compressstore>llvm.intr.masked.compressstore (::mlir::LLVM::masked_compressstore)</a></li><li><a href=#llvmintrmaskedexpandload-mlirllvmmasked_expandload>llvm.intr.masked.expandload (::mlir::LLVM::masked_expandload)</a></li><li><a href=#llvmintrmaskedgather-mlirllvmmasked_gather>llvm.intr.masked.gather (::mlir::LLVM::masked_gather)</a></li><li><a href=#llvmintrmaskedscatter-mlirllvmmasked_scatter>llvm.intr.masked.scatter (::mlir::LLVM::masked_scatter)</a></li><li><a href=#llvmintrvectorreduceadd-mlirllvmvector_reduce_add>llvm.intr.vector.reduce.add (::mlir::LLVM::vector_reduce_add)</a></li><li><a href=#llvmintrvectorreduceand-mlirllvmvector_reduce_and>llvm.intr.vector.reduce.and (::mlir::LLVM::vector_reduce_and)</a></li><li><a href=#llvmintrvectorreducefadd-mlirllvmvector_reduce_fadd>llvm.intr.vector.reduce.fadd (::mlir::LLVM::vector_reduce_fadd)</a></li><li><a href=#llvmintrvectorreducefmax-mlirllvmvector_reduce_fmax>llvm.intr.vector.reduce.fmax (::mlir::LLVM::vector_reduce_fmax)</a></li><li><a href=#llvmintrvectorreducefmin-mlirllvmvector_reduce_fmin>llvm.intr.vector.reduce.fmin (::mlir::LLVM::vector_reduce_fmin)</a></li><li><a href=#llvmintrvectorreducefmul-mlirllvmvector_reduce_fmul>llvm.intr.vector.reduce.fmul (::mlir::LLVM::vector_reduce_fmul)</a></li><li><a href=#llvmintrvectorreducemul-mlirllvmvector_reduce_mul>llvm.intr.vector.reduce.mul (::mlir::LLVM::vector_reduce_mul)</a></li><li><a href=#llvmintrvectorreduceor-mlirllvmvector_reduce_or>llvm.intr.vector.reduce.or (::mlir::LLVM::vector_reduce_or)</a></li><li><a href=#llvmintrvectorreducesmax-mlirllvmvector_reduce_smax>llvm.intr.vector.reduce.smax (::mlir::LLVM::vector_reduce_smax)</a></li><li><a href=#llvmintrvectorreducesmin-mlirllvmvector_reduce_smin>llvm.intr.vector.reduce.smin (::mlir::LLVM::vector_reduce_smin)</a></li><li><a href=#llvmintrvectorreduceumax-mlirllvmvector_reduce_umax>llvm.intr.vector.reduce.umax (::mlir::LLVM::vector_reduce_umax)</a></li><li><a href=#llvmintrvectorreduceumin-mlirllvmvector_reduce_umin>llvm.intr.vector.reduce.umin (::mlir::LLVM::vector_reduce_umin)</a></li><li><a href=#llvmintrvectorreducexor-mlirllvmvector_reduce_xor>llvm.intr.vector.reduce.xor (::mlir::LLVM::vector_reduce_xor)</a></li></ul></li></ul></nav><h2 id=dependency-on-llvm-ir>Dependency on LLVM IR&nbsp;<a class=headline-hash href=#dependency-on-llvm-ir>¶</a></h2><p>LLVM dialect is not expected to depend on any object that requires an
<code>LLVMContext</code>, such as an LLVM IR instruction or type. Instead, MLIR provides
thread-safe alternatives compatible with the rest of the infrastructure. The
dialect is allowed to depend on the LLVM IR objects that don&rsquo;t require a
context, such as data layout and triple description.</p><h2 id=module-structure>Module Structure&nbsp;<a class=headline-hash href=#module-structure>¶</a></h2><p>IR modules use the built-in MLIR <code>ModuleOp</code> and support all its features. In
particular, modules can be named, nested and are subject to symbol visibility.
Modules can contain any operations, including LLVM functions and globals.</p><h3 id=data-layout-and-triple>Data Layout and Triple&nbsp;<a class=headline-hash href=#data-layout-and-triple>¶</a></h3><p>An IR module may have an optional data layout and triple information attached
using MLIR attributes <code>llvm.data_layout</code> and <code>llvm.triple</code>, respectively. Both
are string attributes with the
<a href=https://llvm.org/docs/LangRef.html#data-layout>same syntax</a>
as in LLVM IR and
are verified to be correct. They can be defined as follows.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>module attributes <span class=p>{</span><span class=nl>llvm.data_layout =</span> <span class=s>&#34;e&#34;</span><span class=p>,</span>
                   <span class=nl>llvm.target_triple =</span> <span class=s>&#34;aarch64-linux-android&#34;</span><span class=p>}</span> <span class=p>{</span>
  <span class=c>// module contents
</span><span class=c></span><span class=p>}</span>
</code></pre></div><h3 id=functions>Functions&nbsp;<a class=headline-hash href=#functions>¶</a></h3><p>LLVM functions are represented by a special operation, <code>llvm.func</code>, that has
syntax similar to that of the built-in function operation but supports
LLVM-related features such as linkage and variadic argument lists. See detailed
description in the operation list
<a href=#llvmfunc-mlirllvmllvmfuncop>below</a>
.</p><h3 id=phi-nodes-and-block-arguments>PHI Nodes and Block Arguments&nbsp;<a class=headline-hash href=#phi-nodes-and-block-arguments>¶</a></h3><p>MLIR uses block arguments instead of PHI nodes to communicate values between
blocks. Therefore, the LLVM dialect has no operation directly equivalent to
<code>phi</code> in LLVM IR. Instead, all terminators can pass values as successor operands
as these values will be forwarded as block arguments when the control flow is
transferred.</p><p>For example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nl>^bb1</span><span class=p>:</span>
  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>addi <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%cst</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>
  llvm<span class=p>.</span>br <span class=nl>^bb2</span><span class=p>[</span><span class=nv>%0</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>]</span>

<span class=c>// If the control flow comes from ^bb1, %arg1 == %0.
</span><span class=c></span><span class=nl>^bb2</span><span class=p>(</span><span class=nv>%arg1</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span>
  <span class=c>// ...
</span></code></pre></div><p>is equivalent to LLVM IR</p><div class=highlight><pre class=chroma><code class=language-llvm data-lang=llvm><span class=n>%0</span><span class=err>:</span>
  <span class=n>%1</span> <span class=p>=</span> <span class=k>add</span> <span class=k>i32</span> <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%cst</span>
  <span class=k>br</span> <span class=n>%3</span>

<span class=n>%3</span><span class=err>:</span>
  <span class=nv>%arg1</span> <span class=p>=</span> <span class=k>phi</span> <span class=p>[</span><span class=n>%1</span><span class=p>,</span> <span class=n>%0</span><span class=p>]</span><span class=p>,</span> <span class=err>/</span><span class=err>/</span><span class=p>.</span><span class=p>.</span><span class=p>.</span>
</code></pre></div><p>Since there is no need to use the block identifier to differentiate the source
of different values, the LLVM dialect supports terminators that transfer the
control flow to the same block with different arguments. For example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nl>^bb1</span><span class=p>:</span>
  llvm<span class=p>.</span>cond_br <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^bb2</span><span class=p>[</span><span class=nv>%0</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>]</span><span class=p>,</span> <span class=nl>^bb2</span><span class=p>[</span><span class=nv>%1</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>]</span>

<span class=nl>^bb2</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span><span class=p>:</span>
  <span class=c>// ...
</span></code></pre></div><h3 id=context-level-values>Context-Level Values&nbsp;<a class=headline-hash href=#context-level-values>¶</a></h3><p>Some value kinds in LLVM IR, such as constants and undefs, are uniqued in
context and used directly in relevant operations. MLIR does not support such
values for thread-safety and concept parsimony reasons. Instead, regular values
are produced by dedicated operations that have the corresponding semantics:
<a href=#llvmmlirconstant-mlirllvmconstantop><code>llvm.mlir.constant</code></a>
,
<a href=#llvmmlirundef-mlirllvmundefop><code>llvm.mlir.undef</code></a>
,
<a href=#llvmmlirnull-mlirnullop><code>llvm.mlir.null</code></a>
. Note how these operations are
prefixed with <code>mlir.</code> to indicate that they don&rsquo;t belong to LLVM IR but are only
necessary to model it in MLIR. The values produced by these operations are
usable just like any other value.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Create an undefined value of structure type with a 32-bit integer followed
</span><span class=c></span><span class=c>// by a float.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>undef <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=p>(</span><span class=k>i32</span><span class=p>,</span> float<span class=p>)</span><span class=p>&gt;</span>

<span class=c>// Null pointer to i8.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>null <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>

<span class=c>// Null pointer to a function with signature void().
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>null <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>(</span><span class=p>)</span><span class=p>&gt;</span><span class=p>&gt;</span>

<span class=c>// Constant 42 as i32.
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>

<span class=c>// Splat dense vector constant.
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span>dense<span class=p>&lt;</span><span class=m>1.0</span><span class=p>&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>vec<span class=p>&lt;</span><span class=m>4 x</span> float<span class=p>&gt;</span>
</code></pre></div><p>Note that constants use built-in types within the initializer definition: MLIR
attributes are typed and the attributes used for constants require a built-in
type.</p><h3 id=globals>Globals&nbsp;<a class=headline-hash href=#globals>¶</a></h3><p>Global variables are also defined using a special operation,
<a href=#llvmmlirglobal-mlirllvmglobalop><code>llvm.mlir.global</code></a>
, located at the module
level. Globals are MLIR symbols and are identified by their name.</p><p>Since functions need to be isolated-from-above, i.e. values defined outside the
function cannot be directly used inside the function, an additional operation,
<a href=#llvmmliraddressof-mlirllvmaddressofop><code>llvm.mlir.addressof</code></a>
, is provided to
locally define a value containing the <em>address</em> of a global. The actual value
can then be loaded from that pointer, or a new value can be stored into it if
the global is not declared constant. This is similar to LLVM IR where globals
are accessed through name and have a pointer type.</p><h3 id=linkage>Linkage&nbsp;<a class=headline-hash href=#linkage>¶</a></h3><p>Module-level named objects in the LLVM dialect, namely functions and globals,
have an optional <em>linkage</em> attribute derived from LLVM IR
<a href=https://llvm.org/docs/LangRef.html#linkage-types>linkage types</a>
. Linkage is
specified by the same keyword as in LLVM IR and is located between the operation
name (<code>llvm.func</code> or <code>llvm.global</code>) and the symbol name. If no linkage keyword
is present, <code>external</code> linkage is assumed by default. Linakge is <em>distinct</em> from
MLIR symbol visibility.</p><h3 id=attribute-pass-through>Attribute Pass-Through&nbsp;<a class=headline-hash href=#attribute-pass-through>¶</a></h3><p>The LLVM dialect provides a mechanism to forward function-level attributes to
LLVM IR using the <code>passthrough</code> attribute. This is an array attribute containing
either string attributes or array attributes. In the former case, the value of
the string is interpreted as the name of LLVM IR function attribute. In the
latter case, the array is expected to contain exactly two string attributes, the
first corresponding to the name of LLVM IR function attribute, and the second
corresponding to its value. Note that even integer LLVM IR function attributes
have their value represented in the string form.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@func</span><span class=p>(</span><span class=p>)</span> attributes <span class=p>{</span>
  <span class=nl>passthrough =</span> <span class=p>[</span><span class=s>&#34;noinline&#34;</span><span class=p>,</span>           <span class=c>// value-less attribute
</span><span class=c></span>                 <span class=p>[</span><span class=s>&#34;alignstack&#34;</span><span class=p>,</span> <span class=s>&#34;4&#34;</span><span class=p>]</span><span class=p>,</span>  <span class=c>// integer attribute with value
</span><span class=c></span>                 <span class=p>[</span><span class=s>&#34;other&#34;</span><span class=p>,</span> <span class=s>&#34;attr&#34;</span><span class=p>]</span><span class=p>]</span>    <span class=c>// attribute unknown to LLVM
</span><span class=c></span><span class=p>}</span> <span class=p>{</span>
  llvm<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><p>If the attribute is not known to LLVM IR, it will be attached as a string
attribute.</p><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><p>LLVM dialect defines a set of types that correspond to LLVM IR types. The
dialect type system is <em>closed</em>: types from other dialects are not allowed
within LLVM dialect aggregate types. This property allows for more concise
custom syntax and ensures easy translation to LLVM IR.</p><p>Similarly to other MLIR context-owned objects, the creation and manipulation of
LLVM dialect types is thread-safe.</p><p>MLIR does not support module-scoped named type declarations, e.g. <code>%s = type {i32, i32}</code> in LLVM IR. Instead, types must be fully specified at each use,
except for recursive types where only the first reference to a named type needs
to be fully specified. MLIR type aliases are supported for top-level types, i.e.
they cannot be used inside the type due to type system closedness.</p><p>The general syntax of LLVM dialect types is <code>!llvm.</code>, followed by a type kind
identifier (e.g., <code>ptr</code> for pointer or <code>struct</code> for structure) and by an
optional list of type parameters in angle brackets. The dialect follows MLIR
style for types with nested angle brackets and keyword specifiers rather than
using different bracket styles to differentiate types. Inside angle brackets,
the <code>!llvm</code> prefix is omitted for brevity; thanks to closedness of the type
system, all types are assumed to be defined in the LLVM dialect. For example,
<code>!llvm.ptr&lt;struct&lt;packed, (i8, i32)>></code> is a pointer to a packed structure type
containing an 8-bit and a 32-bit integer.</p><h3 id=simple-types>Simple Types&nbsp;<a class=headline-hash href=#simple-types>¶</a></h3><p>The following non-parametric types are supported.</p><ul><li><code>!llvm.bfloat</code> (<code>LLVMBFloatType</code>) - 16-bit “brain” floating-point value
(7-bit significand).</li><li><code>!llvm.half</code> (<code>LLVMHalfType</code>) - 16-bit floating-point value as per
IEEE-754-2008.</li><li><code>!llvm.float</code> (<code>LLVMFloatType</code>) - 32-bit floating-point value as per
IEEE-754-2008.</li><li><code>!llvm.double</code> (<code>LLVMDoubleType</code>) - 64-bit floating-point value as per
IEEE-754-2008.</li><li><code>!llvm.fp128</code> (<code>LLVMFP128Type</code>) - 128-bit floating-point value as per
IEEE-754-2008.</li><li><code>!llvm.x86_fp80</code> (<code>LLVMX86FP80Type</code>) - 80-bit floating-point value (x87).</li><li><code>!llvm.x86_mmx</code> (<code>LLVMX86MMXType</code>) - value held in an MMX register on x86
machine.</li><li><code>!llvm.ppc_fp128</code> (<code>LLVMPPCFP128Type</code>) - 128-bit floating-point value (two
64 bits).</li><li><code>!llvm.token</code> (<code>LLVMTokenType</code>) - a non-inspectable value associated with an
operation.</li><li><code>!llvm.metadata</code> (<code>LLVMMetadataType</code>) - LLVM IR metadata, to be used only if
the metadata cannot be represented as structured MLIR attributes.</li><li><code>!llvm.void</code> (<code>LLVMVoidType</code>) - does not represent any value; can only
appear in function results.</li></ul><p>These types represent a single value (or an absence thereof in case of <code>void</code>)
and correspond to their LLVM IR counterparts.</p><h3 id=parametric-types>Parametric Types&nbsp;<a class=headline-hash href=#parametric-types>¶</a></h3><h4 id=integer-types>Integer Types&nbsp;<a class=headline-hash href=#integer-types>¶</a></h4><p>Integer types are parametric in MLIR terminology, with their bitwidth being a
type parameter. They are expressed as follows:</p><pre><code>  llvm-int-type ::= `!llvm.i` integer-literal
</code></pre><p>and represented internally as <code>LLVMIntegerType</code>. For example, <code>i1</code> is a 1-bit
integer type (bool) and <code>i32</code> as a 32-bit integer type.</p><h4 id=pointer-types>Pointer Types&nbsp;<a class=headline-hash href=#pointer-types>¶</a></h4><p>Pointer types specify an address in memory.</p><p>Pointer types are parametric types parameterized by the element type and the
address space. The address space is an integer, but this choice may be
reconsidered if MLIR implements named address spaces. Their syntax is as
follows:</p><pre><code>  llvm-ptr-type ::= `!llvm.ptr&lt;` llvm-type (`,` integer-literal)? `&gt;`
</code></pre><p>where the optional integer literal corresponds to the memory space. Both cases
are represented by <code>LLVMPointerType</code> internally.</p><h4 id=vector-types>Vector Types&nbsp;<a class=headline-hash href=#vector-types>¶</a></h4><p>Vector types represent sequences of elements, typically when multiple data
elements are processed by a single instruction (SIMD). Vectors are thought of as
stored in registers and therefore vector elements can only be addressed through
constant indices.</p><p>Vector types are parameterized by the size, which may be either <em>fixed</em> or a
multiple of some fixed size in case of <em>scalable</em> vectors, and the element type.
Vectors cannot be nested and only 1D vectors are supported. Scalable vectors are
still considered 1D. Their syntax is as follows:</p><pre><code>  llvm-vec-type ::= `!llvm.vec&lt;` (`?` `x`)? integer-literal `x` llvm-type `&gt;`
</code></pre><p>Internally, fixed vector types are represented as <code>LLVMFixedVectorType</code> and
scalable vector types are represented as <code>LLVMScalableVectorType</code>. Both classes
derive<code>LLVMVectorType</code>.</p><h4 id=array-types>Array Types&nbsp;<a class=headline-hash href=#array-types>¶</a></h4><p>Array types represent sequences of elements in memory. Unlike vectors, array
elements can be addressed with a value unknown at compile time, and can be
nested. Only 1D arrays are allowed though.</p><p>Array types are parameterized by the fixed size and the element type.
Syntactically, their representation is close to vectors:</p><pre><code>  llvm-array-type ::= `!llvm.array&lt;` integer-literal `x` llvm-type `&gt;`
</code></pre><p>and are internally represented as <code>LLVMArrayType</code>.</p><h4 id=function-types>Function Types&nbsp;<a class=headline-hash href=#function-types>¶</a></h4><p>Function types represent the type of a function, i.e. its signature.</p><p>Function types are parameterized by the result type, the list of argument types
and by an optional &ldquo;variadic&rdquo; flag. Unlike built-in <code>FunctionType</code>, LLVM dialect
functions (<code>LLVMFunctionType</code>) always have single result, which may be
<code>!llvm.void</code> if the function does not return anything. The syntax is as follows:</p><pre><code>  llvm-func-type ::= `!llvm.func&lt;` llvm-type `(` llvm-type-list (`,` `...`)?
                     `)` `&gt;`
</code></pre><p>For example,</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>(</span><span class=p>)</span><span class=p>&gt;</span>            <span class=c>// a function with no arguments;
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span><span class=k>i32</span> <span class=p>(</span>float<span class=p>,</span> <span class=k>i32</span><span class=p>)</span><span class=p>&gt;</span>  <span class=c>// a function with two arguments and a result;
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span><span class=p>&gt;</span>   <span class=c>// a variadic function with at least one argument.
</span></code></pre></div><p>In the LLVM dialect, functions are not first-class objects and one cannot have a
value of function type. Instead, one can take the address of a function and
operate on pointers to functions.</p><h3 id=structure-types>Structure Types&nbsp;<a class=headline-hash href=#structure-types>¶</a></h3><p>The structure type is used to represent a collection of data members together in
memory. The elements of a structure may be any type that has a size.</p><p>Structure types are represented in a single dedicated class
mlir::LLVM::LLVMStructType. Internally, the struct type stores a (potentially
empty) name, a (potentially empty) list of contained types and a bitmask
indicating whether the struct is named, opaque, packed or uninitialized.
Structure types that don&rsquo;t have a name are referred to as <em>literal</em> structs.
Such structures are uniquely identified by their contents. <em>Identified</em> structs
on the other hand are uniquely identified by the name.</p><h4 id=identified-structure-types>Identified Structure Types&nbsp;<a class=headline-hash href=#identified-structure-types>¶</a></h4><p>Identified structure types are uniqued using their name in a given context.
Attempting to construct an identified structure with the same name a structure
that already exists in the context <em>will result in the existing structure being
returned</em>. <strong>MLIR does not auto-rename identified structs in case of name
conflicts</strong> because there is no naming scope equivalent to a module in LLVM IR
since MLIR modules can be arbitrarily nested.</p><p>Programmatically, identified structures can be constructed in an <em>uninitialized</em>
state. In this case, they are given a name but the body must be set up by a
later call, using MLIR&rsquo;s type mutation mechanism. Such uninitialized types can
be used in type construction, but must be eventually initialized for IR to be
valid. This mechanism allows for constructing <em>recursive</em> or mutually referring
structure types: an uninitialized type can be used in its own initialization.</p><p>Once the type is initialized, its body cannot be changed anymore. Any further
attempts to modify the body will fail and return failure to the caller <em>unless
the type is initialized with the exact same body</em>. Type initialization is
thread-safe; however, if a concurrent thread initializes the type before the
current thread, the initialization may return failure.</p><p>The syntax for identified structure types is as follows.</p><pre><code>llvm-ident-struct-type ::= `!llvm.struct&lt;` string-literal, `opaque` `&gt;`
                         | `!llvm.struct&lt;` string-literal, `packed`?
                            `(` llvm-type-or-ref-list  `)` `&gt;`
llvm-type-or-ref-list ::= &lt;maybe empty comma-separated list of llvm-type-or-ref&gt;
llvm-type-or-ref ::= &lt;any llvm type&gt;
                   | `!llvm.struct&lt;` string-literal &gt;
</code></pre><p>The body of the identified struct is printed in full unless the it is
transitively contained in the same struct. In the latter case, only the
identifier is printed. For example, the structure containing the pointer to
itself is represented as <code>!llvm.struct&lt;"A", (ptr&lt;"A">)></code>, and the structure <code>A</code>
containing two pointers to the structure <code>B</code> containing a pointer to the
structure <code>A</code> is represented as <code>!llvm.struct&lt;"A", (ptr&lt;"B", (ptr&lt;"A">)>, ptr&lt;"B", (ptr&lt;"A">))></code>. Note that the structure <code>B</code> is &ldquo;unrolled&rdquo; for both
elements. <em>A structure with the same name but different body is a syntax error.</em>
<strong>The user must ensure structure name uniqueness across all modules processed in
a given MLIR context.</strong> Stucture names are arbitrary string literals and may
include, e.g., spaces and keywords.</p><p>Identified structs may be <em>opaque</em>. In this case, the body is unknown but the
structure type is considered <em>initialized</em> and is valid in the IR.</p><h4 id=literal-structure-types>Literal Structure Types&nbsp;<a class=headline-hash href=#literal-structure-types>¶</a></h4><p>Literal structures are uniqued according to the list of elements they contain,
and can optionally be packed. The syntax for such structs is as follows.</p><pre><code>llvm-literal-struct-type ::= `!llvm.struct&lt;` `packed`? `(` llvm-type-list `)`
                             `&gt;`
llvm-type-list ::= &lt;maybe empty comma-separated list of llvm types w/o `!llvm`&gt;
</code></pre><p>Literal structs cannot be recursive, but can contain other structs. Therefore,
they must be constructed in a single step with the entire list of contained
elements provided.</p><h4 id=examples-of-structure-types>Examples of Structure Types&nbsp;<a class=headline-hash href=#examples-of-structure-types>¶</a></h4><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=p>&gt;</span>                  <span class=c>// NOT allowed
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=p>(</span><span class=p>)</span><span class=p>&gt;</span>                <span class=c>// empty, literal
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=p>(</span><span class=k>i32</span><span class=p>)</span><span class=p>&gt;</span>             <span class=c>// literal
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=p>(</span>struct<span class=p>&lt;</span><span class=p>(</span><span class=k>i32</span><span class=p>)</span><span class=p>&gt;</span><span class=p>)</span><span class=p>&gt;</span>   <span class=c>// struct containing a struct
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span>packed <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span><span class=p>&gt;</span>  <span class=c>// packed struct
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=s>&#34;a&#34;</span><span class=p>&gt;</span>               <span class=c>// recursive reference, only allowed within
</span><span class=c></span>                                <span class=c>// another struct, NOT allowed at top level
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=s>&#34;a&#34;</span><span class=p>,</span> ptr<span class=p>&lt;</span>struct<span class=p>&lt;</span><span class=s>&#34;a&#34;</span><span class=p>&gt;</span><span class=p>&gt;</span><span class=p>&gt;</span>  <span class=c>// supported example of recursive reference
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=s>&#34;a&#34;</span><span class=p>,</span> <span class=p>(</span><span class=p>)</span><span class=p>&gt;</span>           <span class=c>// empty, named (necessary to differentiate from
</span><span class=c></span>                                <span class=c>// recursive reference)
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=s>&#34;a&#34;</span><span class=p>,</span> opaque<span class=p>&gt;</span>       <span class=c>// opaque, named
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=s>&#34;a&#34;</span><span class=p>,</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span><span class=p>&gt;</span>        <span class=c>// named
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=s>&#34;a&#34;</span><span class=p>,</span> packed <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span><span class=p>&gt;</span>  <span class=c>// named, packed
</span></code></pre></div><h3 id=unsupported-types>Unsupported Types&nbsp;<a class=headline-hash href=#unsupported-types>¶</a></h3><p>LLVM IR <code>label</code> type does not have a counterpart in the LLVM dialect since, in
MLIR, blocks are not values and don&rsquo;t need a type.</p><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p>All operations in the LLVM IR dialect have a custom form in MLIR. The mnemonic
of an operation is that used in LLVM IR prefixed with &ldquo;<code>llvm.</code>&rdquo;.</p><h3 id=llvmashr-mlirllvmashrop><code>llvm.ashr</code> (::mlir::LLVM::AShrOp)&nbsp;<a class=headline-hash href=#llvmashr-mlirllvmashrop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.ashr` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr><tr><td align=center><code>rhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmadd-mlirllvmaddop><code>llvm.add</code> (::mlir::LLVM::AddOp)&nbsp;<a class=headline-hash href=#llvmadd-mlirllvmaddop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.add` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr><tr><td align=center><code>rhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmaddrspacecast-mlirllvmaddrspacecastop><code>llvm.addrspacecast</code> (::mlir::LLVM::AddrSpaceCastOp)&nbsp;<a class=headline-hash href=#llvmaddrspacecast-mlirllvmaddrspacecastop>¶</a></h3><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>LLVM pointer type or LLVM vector of LLVM pointer type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM pointer type or LLVM vector of LLVM pointer type</td></tr></tbody></table><h3 id=llvmmliraddressof-mlirllvmaddressofop><code>llvm.mlir.addressof</code> (::mlir::LLVM::AddressOfOp)&nbsp;<a class=headline-hash href=#llvmmliraddressof-mlirllvmaddressofop>¶</a></h3><p>Creates a pointer pointing to a global or a function</p><p>Syntax:</p><pre><code>operation ::= `llvm.mlir.addressof` $global_name attr-dict `:` type($res)
</code></pre><p>Creates an SSA value containing a pointer to a global variable or constant
defined by <code>llvm.mlir.global</code>. The global value can be defined after its
first referenced. If the global value is a constant, storing into it is not
allowed.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=c>// Get the address of a global variable.
</span><span class=c></span>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@const</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>

  <span class=c>// Use it as a regular pointer.
</span><span class=c></span>  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>load <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>

  <span class=c>// Get the address of a function.
</span><span class=c></span>  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@foo</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>(</span><span class=p>)</span><span class=p>&gt;</span><span class=p>&gt;</span>

  <span class=c>// The function address can be used for indirect calls.
</span><span class=c></span>  llvm<span class=p>.</span>call <span class=nv>%2</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
<span class=p>}</span>

<span class=c>// Define the global.
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=nf>@const</span><span class=p>(</span><span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>
</code></pre></div><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>global_name</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmalloca-mlirllvmallocaop><code>llvm.alloca</code> (::mlir::LLVM::AllocaOp)&nbsp;<a class=headline-hash href=#llvmalloca-mlirllvmallocaop>¶</a></h3><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>alignment</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arraySize</code></td><td>LLVM integer type</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmand-mlirllvmandop><code>llvm.and</code> (::mlir::LLVM::AndOp)&nbsp;<a class=headline-hash href=#llvmand-mlirllvmandop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.and` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr><tr><td align=center><code>rhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmintrassume-mlirllvmassumeop><code>llvm.intr.assume</code> (::mlir::LLVM::AssumeOp)&nbsp;<a class=headline-hash href=#llvmintrassume-mlirllvmassumeop>¶</a></h3><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>cond</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmcmpxchg-mlirllvmatomiccmpxchgop><code>llvm.cmpxchg</code> (::mlir::LLVM::AtomicCmpXchgOp)&nbsp;<a class=headline-hash href=#llvmcmpxchg-mlirllvmatomiccmpxchgop>¶</a></h3><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>success_ordering</code></td><td align=center>::mlir::IntegerAttr</td><td>Atomic ordering for LLVM&rsquo;s memory model</td></tr><tr><td align=center><code>failure_ordering</code></td><td align=center>::mlir::IntegerAttr</td><td>Atomic ordering for LLVM&rsquo;s memory model</td></tr></tbody></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>ptr</code></td><td>LLVM pointer to LLVM integer type or LLVM pointer type</td></tr><tr><td align=center><code>cmp</code></td><td>LLVM integer type or LLVM pointer type</td></tr><tr><td align=center><code>val</code></td><td>LLVM integer type or LLVM pointer type</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>an LLVM struct type with any integer or pointer followed by a single-bit integer</td></tr></tbody></table><h3 id=llvmatomicrmw-mlirllvmatomicrmwop><code>llvm.atomicrmw</code> (::mlir::LLVM::AtomicRMWOp)&nbsp;<a class=headline-hash href=#llvmatomicrmw-mlirllvmatomicrmwop>¶</a></h3><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>bin_op</code></td><td align=center>::mlir::IntegerAttr</td><td>llvm.atomicrmw binary operations</td></tr><tr><td align=center><code>ordering</code></td><td align=center>::mlir::IntegerAttr</td><td>Atomic ordering for LLVM&rsquo;s memory model</td></tr></tbody></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>ptr</code></td><td>LLVM pointer to floating point LLVM type or LLVM integer type</td></tr><tr><td align=center><code>val</code></td><td>floating point LLVM type or LLVM integer type</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>floating point LLVM type or LLVM integer type</td></tr></tbody></table><h3 id=llvmintrbitreverse-mlirllvmbitreverseop><code>llvm.intr.bitreverse</code> (::mlir::LLVM::BitReverseOp)&nbsp;<a class=headline-hash href=#llvmintrbitreverse-mlirllvmbitreverseop>¶</a></h3><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmbitcast-mlirllvmbitcastop><code>llvm.bitcast</code> (::mlir::LLVM::BitcastOp)&nbsp;<a class=headline-hash href=#llvmbitcast-mlirllvmbitcastop>¶</a></h3><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>LLVM non-aggregate type</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM non-aggregate type</td></tr></tbody></table><h3 id=llvmbr-mlirllvmbrop><code>llvm.br</code> (::mlir::LLVM::BrOp)&nbsp;<a class=headline-hash href=#llvmbr-mlirllvmbrop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.br` $dest (`(` $destOperands^ `:` type($destOperands) `)`)? attr-dict
</code></pre><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>destOperands</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=successors>Successors:&nbsp;<a class=headline-hash href=#successors>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>any successor</td></tr></tbody></table><h3 id=llvmcall-mlirllvmcallop><code>llvm.call</code> (::mlir::LLVM::CallOp)&nbsp;<a class=headline-hash href=#llvmcall-mlirllvmcallop>¶</a></h3><p>Call to an LLVM function.</p><p>In LLVM IR, functions may return either 0 or 1 value. LLVM IR dialect
implements this behavior by providing a variadic <code>call</code> operation for 0- and
1-result functions. Even though MLIR supports multi-result functions, LLVM
IR dialect disallows them.</p><p>The <code>call</code> instruction supports both direct and indirect calls. Direct calls
start with a function name (<code>@</code>-prefixed) and indirect calls start with an
SSA value (<code>%</code>-prefixed). The direct callee, if present, is stored as a
function attribute <code>callee</code>. The trailing type of the instruction is always
the MLIR function type, which may be different from the indirect callee that
has the wrapped LLVM IR function type.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Direct call without arguments and with one result.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>call <span class=nf>@foo</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span>float<span class=p>)</span>

<span class=c>// Direct call with arguments and without a result.
</span><span class=c></span>llvm<span class=p>.</span>call <span class=nf>@bar</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span>float<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>

<span class=c>// Indirect call with an argument and without a result.
</span><span class=c></span>llvm<span class=p>.</span>call <span class=nv>%1</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span>float<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
</code></pre></div><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>callee</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmcond_br-mlirllvmcondbrop><code>llvm.cond_br</code> (::mlir::LLVM::CondBrOp)&nbsp;<a class=headline-hash href=#llvmcond_br-mlirllvmcondbrop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.cond_br` $condition ( `weights` `(` $branch_weights^ `)` )? `,`
              $trueDest (`(` $trueDestOperands^ `:` type($trueDestOperands) `)`)? `,`
              $falseDest (`(` $falseDestOperands^ `:` type($falseDestOperands) `)`)?
              attr-dict
</code></pre><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>branch_weights</code></td><td align=center>::mlir::ElementsAttr</td><td>constant vector/tensor attribute</td></tr></tbody></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>condition</code></td><td>LLVM 1-bit integer type</td></tr><tr><td align=center><code>trueDestOperands</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>falseDestOperands</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=successors-1>Successors:&nbsp;<a class=headline-hash href=#successors-1>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>trueDest</code></td><td>any successor</td></tr><tr><td align=center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=llvmmlirconstant-mlirllvmconstantop><code>llvm.mlir.constant</code> (::mlir::LLVM::ConstantOp)&nbsp;<a class=headline-hash href=#llvmmlirconstant-mlirllvmconstantop>¶</a></h3><p>Defines a constant of LLVM type.</p><p>Syntax:</p><pre><code>operation ::= `llvm.mlir.constant` `(` $value `)` attr-dict `:` type($res)
</code></pre><p>Unlike LLVM IR, MLIR does not have first-class constant values. Therefore,
all constants must be created as SSA values before being used in other
operations. <code>llvm.mlir.constant</code> creates such values for scalars and
vectors. It has a mandatory <code>value</code> attribute, which may be an integer,
floating point attribute; dense or sparse attribute containing integers or
floats. The type of the attribute is one of the corresponding MLIR builtin
types. It may be omitted for <code>i64</code> and <code>f64</code> types that are implied. The
operation produces a new SSA value of the specified LLVM IR dialect type.
The type of that value <em>must</em> correspond to the attribute type converted to
LLVM IR.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Integer constant, internal i32 is mandatory
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>

<span class=c>// It&#39;s okay to omit i64.
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>42</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>

<span class=c>// Floating point constant.
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>42.0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>float

<span class=c>// Splat dense vector constant.
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span>dense<span class=p>&lt;</span><span class=m>1.0</span><span class=p>&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>vec<span class=p>&lt;</span><span class=m>4 x</span> float<span class=p>&gt;</span>
</code></pre></div><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>::mlir::Attribute</td><td>any attribute</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrcopysign-mlirllvmcopysignop><code>llvm.intr.copysign</code> (::mlir::LLVM::CopySignOp)&nbsp;<a class=headline-hash href=#llvmintrcopysign-mlirllvmcopysignop>¶</a></h3><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>a</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>b</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrcos-mlirllvmcosop><code>llvm.intr.cos</code> (::mlir::LLVM::CosOp)&nbsp;<a class=headline-hash href=#llvmintrcos-mlirllvmcosop>¶</a></h3><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrctpop-mlirllvmctpopop><code>llvm.intr.ctpop</code> (::mlir::LLVM::CtPopOp)&nbsp;<a class=headline-hash href=#llvmintrctpop-mlirllvmctpopop>¶</a></h3><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmmlircast-mlirllvmdialectcastop><code>llvm.mlir.cast</code> (::mlir::LLVM::DialectCastOp)&nbsp;<a class=headline-hash href=#llvmmlircast-mlirllvmdialectcastop>¶</a></h3><p>Type cast between LLVM dialect and Standard.</p><p>Syntax:</p><pre><code>operation ::= `llvm.mlir.cast` $in attr-dict `:` type($in) `to` type($res)
</code></pre><p>llvm.mlir.cast op casts between Standard and LLVM dialects. It only changes
the dialect, but does not change compile-time or runtime semantics.</p><p>Notice that index type is not supported, as it&rsquo;s Standard-specific.</p><p>Example:
llvm.mlir.cast %v : f16 to llvm.half
llvm.mlir.cast %v : llvm.float to f32
llvm.mlir.cast %v : !llvm&lt;"&lt;2 x float>"> to vector&lt;2xf32></p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>any type</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>any type</td></tr></tbody></table><h3 id=llvmintrexp2-mlirllvmexp2op><code>llvm.intr.exp2</code> (::mlir::LLVM::Exp2Op)&nbsp;<a class=headline-hash href=#llvmintrexp2-mlirllvmexp2op>¶</a></h3><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrexp-mlirllvmexpop><code>llvm.intr.exp</code> (::mlir::LLVM::ExpOp)&nbsp;<a class=headline-hash href=#llvmintrexp-mlirllvmexpop>¶</a></h3><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmextractelement-mlirllvmextractelementop><code>llvm.extractelement</code> (::mlir::LLVM::ExtractElementOp)&nbsp;<a class=headline-hash href=#llvmextractelement-mlirllvmextractelementop>¶</a></h3><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>vector</code></td><td>LLVM vector type</td></tr><tr><td align=center><code>position</code></td><td>LLVM integer type</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmextractvalue-mlirllvmextractvalueop><code>llvm.extractvalue</code> (::mlir::LLVM::ExtractValueOp)&nbsp;<a class=headline-hash href=#llvmextractvalue-mlirllvmextractvalueop>¶</a></h3><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>position</code></td><td align=center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>container</code></td><td>LLVM aggregate type</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrfabs-mlirllvmfabsop><code>llvm.intr.fabs</code> (::mlir::LLVM::FAbsOp)&nbsp;<a class=headline-hash href=#llvmintrfabs-mlirllvmfabsop>¶</a></h3><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmfadd-mlirllvmfaddop><code>llvm.fadd</code> (::mlir::LLVM::FAddOp)&nbsp;<a class=headline-hash href=#llvmfadd-mlirllvmfaddop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.fadd` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr><tr><td align=center><code>rhs</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmintrceil-mlirllvmfceilop><code>llvm.intr.ceil</code> (::mlir::LLVM::FCeilOp)&nbsp;<a class=headline-hash href=#llvmintrceil-mlirllvmfceilop>¶</a></h3><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmfcmp-mlirllvmfcmpop><code>llvm.fcmp</code> (::mlir::LLVM::FCmpOp)&nbsp;<a class=headline-hash href=#llvmfcmp-mlirllvmfcmpop>¶</a></h3><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>predicate</code></td><td align=center>::mlir::IntegerAttr</td><td>llvm.fcmp comparison predicate</td></tr></tbody></table><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr><tr><td align=center><code>rhs</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM 1-bit integer type or LLVM vector of LLVM 1-bit integer type</td></tr></tbody></table><h3 id=llvmfdiv-mlirllvmfdivop><code>llvm.fdiv</code> (::mlir::LLVM::FDivOp)&nbsp;<a class=headline-hash href=#llvmfdiv-mlirllvmfdivop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.fdiv` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr><tr><td align=center><code>rhs</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmintrfloor-mlirllvmffloorop><code>llvm.intr.floor</code> (::mlir::LLVM::FFloorOp)&nbsp;<a class=headline-hash href=#llvmintrfloor-mlirllvmffloorop>¶</a></h3><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrfma-mlirllvmfmaop><code>llvm.intr.fma</code> (::mlir::LLVM::FMAOp)&nbsp;<a class=headline-hash href=#llvmintrfma-mlirllvmfmaop>¶</a></h3><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>a</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>b</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>c</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrfmuladd-mlirllvmfmuladdop><code>llvm.intr.fmuladd</code> (::mlir::LLVM::FMulAddOp)&nbsp;<a class=headline-hash href=#llvmintrfmuladd-mlirllvmfmuladdop>¶</a></h3><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>a</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>b</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>c</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmfmul-mlirllvmfmulop><code>llvm.fmul</code> (::mlir::LLVM::FMulOp)&nbsp;<a class=headline-hash href=#llvmfmul-mlirllvmfmulop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.fmul` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr><tr><td align=center><code>rhs</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmfneg-mlirllvmfnegop><code>llvm.fneg</code> (::mlir::LLVM::FNegOp)&nbsp;<a class=headline-hash href=#llvmfneg-mlirllvmfnegop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.fneg` $operand attr-dict `:` type($res)
</code></pre><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operand</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmfpext-mlirllvmfpextop><code>llvm.fpext</code> (::mlir::LLVM::FPExtOp)&nbsp;<a class=headline-hash href=#llvmfpext-mlirllvmfpextop>¶</a></h3><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmfptosi-mlirllvmfptosiop><code>llvm.fptosi</code> (::mlir::LLVM::FPToSIOp)&nbsp;<a class=headline-hash href=#llvmfptosi-mlirllvmfptosiop>¶</a></h3><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmfptoui-mlirllvmfptouiop><code>llvm.fptoui</code> (::mlir::LLVM::FPToUIOp)&nbsp;<a class=headline-hash href=#llvmfptoui-mlirllvmfptouiop>¶</a></h3><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmfptrunc-mlirllvmfptruncop><code>llvm.fptrunc</code> (::mlir::LLVM::FPTruncOp)&nbsp;<a class=headline-hash href=#llvmfptrunc-mlirllvmfptruncop>¶</a></h3><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmfrem-mlirllvmfremop><code>llvm.frem</code> (::mlir::LLVM::FRemOp)&nbsp;<a class=headline-hash href=#llvmfrem-mlirllvmfremop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.frem` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr><tr><td align=center><code>rhs</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmfsub-mlirllvmfsubop><code>llvm.fsub</code> (::mlir::LLVM::FSubOp)&nbsp;<a class=headline-hash href=#llvmfsub-mlirllvmfsubop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.fsub` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr><tr><td align=center><code>rhs</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmfence-mlirllvmfenceop><code>llvm.fence</code> (::mlir::LLVM::FenceOp)&nbsp;<a class=headline-hash href=#llvmfence-mlirllvmfenceop>¶</a></h3><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>ordering</code></td><td align=center>::mlir::IntegerAttr</td><td>Atomic ordering for LLVM&rsquo;s memory model</td></tr><tr><td align=center><code>syncscope</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=llvmfreeze-mlirllvmfreezeop><code>llvm.freeze</code> (::mlir::LLVM::FreezeOp)&nbsp;<a class=headline-hash href=#llvmfreeze-mlirllvmfreezeop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.freeze` $val attr-dict `:` type($val)
</code></pre><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>val</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmgetelementptr-mlirllvmgepop><code>llvm.getelementptr</code> (::mlir::LLVM::GEPOp)&nbsp;<a class=headline-hash href=#llvmgetelementptr-mlirllvmgepop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.getelementptr` $base `[` $indices `]` attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>base</code></td><td>LLVM pointer type or LLVM vector of LLVM pointer type</td></tr><tr><td align=center><code>indices</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM pointer type or LLVM vector of LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrgetactivelanemask-mlirllvmgetactivelanemaskop><code>llvm.intr.get.active.lane.mask</code> (::mlir::LLVM::GetActiveLaneMaskOp)&nbsp;<a class=headline-hash href=#llvmintrgetactivelanemask-mlirllvmgetactivelanemaskop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.intr.get.active.lane.mask` $base `,` $n attr-dict `:` type($base) `,` type($n) `to` type($res)
</code></pre><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>base</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>n</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmmlirglobal-mlirllvmglobalop><code>llvm.mlir.global</code> (::mlir::LLVM::GlobalOp)&nbsp;<a class=headline-hash href=#llvmmlirglobal-mlirllvmglobalop>¶</a></h3><p>LLVM dialect global.</p><p>Since MLIR allows for arbitrary operations to be present at the top level,
global variables are defined using the <code>llvm.mlir.global</code> operation. Both
global constants and variables can be defined, and the value may also be
initialized in both cases.</p><p>There are two forms of initialization syntax. Simple constants that can be
represented as MLIR attributes can be given in-line:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=nf>@variable</span><span class=p>(</span><span class=m>32.0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>float
</code></pre></div><p>This initialization and type syntax is similar to <code>llvm.mlir.constant</code> and
may use two types: one for MLIR attribute and another for the LLVM value.
These types must be compatible.</p><p>More complex constants that cannot be represented as MLIR attributes can be
given in an initializer region:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// This global is initialized with the equivalent of:
</span><span class=c></span><span class=c>//   i32* getelementptr (i32* @g2, i32 2)
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=kt>constant</span> <span class=nf>@int_gep</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@g2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>2</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>
  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>getelementptr <span class=nv>%0</span><span class=p>[</span><span class=nv>%1</span><span class=p>]</span>
     <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
  <span class=c>// The initializer region must end with `llvm.return`.
</span><span class=c></span>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><p>Only one of the initializer attribute or initializer region may be provided.</p><p><code>llvm.mlir.global</code> must appear at top-level of the enclosing module. It uses
an @-identifier for its value, which will be uniqued by the module with
respect to other @-identifiers in it.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Global values use @-identifiers.
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=kt>constant</span> <span class=nf>@cst</span><span class=p>(</span><span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>

<span class=c>// Non-constant values must also be initialized.
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=nf>@variable</span><span class=p>(</span><span class=m>32.0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>float

<span class=c>// Strings are expected to be of wrapped LLVM i8 array type and do not
</span><span class=c></span><span class=c>// automatically include the trailing zero.
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=nf>@string</span><span class=p>(</span><span class=s>&#34;abc&#34;</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3 x</span> <span class=k>i8</span><span class=p>&gt;</span>

<span class=c>// For strings globals, the trailing type may be omitted.
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=kt>constant</span> <span class=nf>@no_trailing_type</span><span class=p>(</span><span class=s>&#34;foo bar&#34;</span><span class=p>)</span>

<span class=c>// A complex initializer is constructed with an initializer region.
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=kt>constant</span> <span class=nf>@int_gep</span><span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@g2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>2</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>
  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>getelementptr <span class=nv>%0</span><span class=p>[</span><span class=nv>%1</span><span class=p>]</span>
     <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
<span class=p>}</span>
</code></pre></div><p>Similarly to functions, globals have a linkage attribute. In the custom
syntax, this attribute is placed between <code>llvm.mlir.global</code> and the optional
<code>constant</code> keyword. If the attribute is omitted, <code>external</code> linkage is
assumed by default.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// A constant with internal linkage will not participate in linking.
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global internal <span class=kt>constant</span> <span class=nf>@cst</span><span class=p>(</span><span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i32</span>

<span class=c>// By default, &#34;external&#34; linkage is assumed and the global participates in
</span><span class=c></span><span class=c>// symbol resolution at link-time.
</span><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=nf>@glob</span><span class=p>(</span><span class=m>0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>float
</code></pre></div><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>type</code></td><td align=center>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td align=center><code>constant</code></td><td align=center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td align=center><code>sym_name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>linkage</code></td><td align=center>::mlir::IntegerAttr</td><td>LLVM linkage types</td></tr><tr><td align=center><code>value</code></td><td align=center>::mlir::Attribute</td><td>any attribute</td></tr><tr><td align=center><code>addr_space</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr></tbody></table><h3 id=llvmicmp-mlirllvmicmpop><code>llvm.icmp</code> (::mlir::LLVM::ICmpOp)&nbsp;<a class=headline-hash href=#llvmicmp-mlirllvmicmpop>¶</a></h3><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>predicate</code></td><td align=center>::mlir::IntegerAttr</td><td>llvm.icmp comparison predicate</td></tr></tbody></table><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr><tr><td align=center><code>rhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM 1-bit integer type or LLVM vector of LLVM 1-bit integer type</td></tr></tbody></table><h3 id=llvminline_asm-mlirllvminlineasmop><code>llvm.inline_asm</code> (::mlir::LLVM::InlineAsmOp)&nbsp;<a class=headline-hash href=#llvminline_asm-mlirllvminlineasmop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.inline_asm` (`has_side_effects` $has_side_effects^)?
              (`is_align_stack` $is_align_stack^)?
              (`asm_dialect` `=` $asm_dialect^)?
              attr-dict
              $asm_string `,` $constraints
              operands `:` functional-type(operands, results)
</code></pre><p>The InlineAsmOp mirrors the underlying LLVM semantics with a notable
exception: the embedded <code>asm_string</code> is not allowed to define or reference
any symbol or any global variable: only the operands of the op may be read,
written, or referenced.
Attempting to define or reference any symbol or any global behavior is
considered undefined behavior at this time.</p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>asm_string</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>constraints</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>has_side_effects</code></td><td align=center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td align=center><code>is_align_stack</code></td><td align=center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td align=center><code>asm_dialect</code></td><td align=center>::mlir::IntegerAttr</td><td>ATT (0) or Intel (1) asm dialect</td></tr></tbody></table><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvminsertelement-mlirllvminsertelementop><code>llvm.insertelement</code> (::mlir::LLVM::InsertElementOp)&nbsp;<a class=headline-hash href=#llvminsertelement-mlirllvminsertelementop>¶</a></h3><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>vector</code></td><td>LLVM vector type</td></tr><tr><td align=center><code>value</code></td><td>primitive LLVM type</td></tr><tr><td align=center><code>position</code></td><td>LLVM integer type</td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM vector type</td></tr></tbody></table><h3 id=llvminsertvalue-mlirllvminsertvalueop><code>llvm.insertvalue</code> (::mlir::LLVM::InsertValueOp)&nbsp;<a class=headline-hash href=#llvminsertvalue-mlirllvminsertvalueop>¶</a></h3><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>position</code></td><td align=center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h4 id=operands-43>Operands:&nbsp;<a class=headline-hash href=#operands-43>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>container</code></td><td>LLVM aggregate type</td></tr><tr><td align=center><code>value</code></td><td>primitive LLVM type</td></tr></tbody></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM aggregate type</td></tr></tbody></table><h3 id=llvminttoptr-mlirllvminttoptrop><code>llvm.inttoptr</code> (::mlir::LLVM::IntToPtrOp)&nbsp;<a class=headline-hash href=#llvminttoptr-mlirllvminttoptrop>¶</a></h3><h4 id=operands-44>Operands:&nbsp;<a class=headline-hash href=#operands-44>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM pointer type or LLVM vector of LLVM pointer type</td></tr></tbody></table><h3 id=llvminvoke-mlirllvminvokeop><code>llvm.invoke</code> (::mlir::LLVM::InvokeOp)&nbsp;<a class=headline-hash href=#llvminvoke-mlirllvminvokeop>¶</a></h3><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>callee</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-45>Operands:&nbsp;<a class=headline-hash href=#operands-45>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>normalDestOperands</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>unwindDestOperands</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=successors-2>Successors:&nbsp;<a class=headline-hash href=#successors-2>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>normalDest</code></td><td>any successor</td></tr><tr><td align=center><code>unwindDest</code></td><td>any successor</td></tr></tbody></table><h3 id=llvmfunc-mlirllvmllvmfuncop><code>llvm.func</code> (::mlir::LLVM::LLVMFuncOp)&nbsp;<a class=headline-hash href=#llvmfunc-mlirllvmllvmfuncop>¶</a></h3><p>LLVM dialect function.</p><p>MLIR functions are defined by an operation that is not built into the IR
itself. The LLVM dialect provides an <code>llvm.func</code> operation to define
functions compatible with LLVM IR. These functions have LLVM dialect
function type but use MLIR syntax to express it. They are required to have
exactly one result type. LLVM function operation is intended to capture
additional properties of LLVM functions, such as linkage and calling
convention, that may be modeled differently by the built-in MLIR function.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// The type of @bar is !llvm&lt;&#34;i64 (i64)&#34;&gt;
</span><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@bar</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span> <span class=p>{</span>
  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%arg0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span>
<span class=p>}</span>

<span class=c>// Type type of @foo is !llvm&lt;&#34;void (i64)&#34;&gt;
</span><span class=c></span><span class=c>// !llvm.void type is omitted
</span><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=k>i64</span><span class=p>)</span> <span class=p>{</span>
  llvm<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>

<span class=c>// A function with `internal` linkage.
</span><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> internal <span class=nf>@internal_func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  llvm<span class=p>.</span><span class=kt>return</span>
<span class=p>}</span>
</code></pre></div><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>linkage</code></td><td align=center>::mlir::IntegerAttr</td><td>LLVM linkage types</td></tr><tr><td align=center><code>personality</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td align=center><code>passthrough</code></td><td align=center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h3 id=llvmlshr-mlirllvmlshrop><code>llvm.lshr</code> (::mlir::LLVM::LShrOp)&nbsp;<a class=headline-hash href=#llvmlshr-mlirllvmlshrop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.lshr` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-46>Operands:&nbsp;<a class=headline-hash href=#operands-46>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr><tr><td align=center><code>rhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmlandingpad-mlirllvmlandingpadop><code>llvm.landingpad</code> (::mlir::LLVM::LandingpadOp)&nbsp;<a class=headline-hash href=#llvmlandingpad-mlirllvmlandingpadop>¶</a></h3><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>cleanup</code></td><td align=center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-47>Operands:&nbsp;<a class=headline-hash href=#operands-47>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmload-mlirllvmloadop><code>llvm.load</code> (::mlir::LLVM::LoadOp)&nbsp;<a class=headline-hash href=#llvmload-mlirllvmloadop>¶</a></h3><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>alignment</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td align=center><code>volatile_</code></td><td align=center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td align=center><code>nontemporal</code></td><td align=center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-48>Operands:&nbsp;<a class=headline-hash href=#operands-48>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>addr</code></td><td>LLVM pointer to LLVM type with size</td></tr></tbody></table><h4 id=results-47>Results:&nbsp;<a class=headline-hash href=#results-47>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrlog10-mlirllvmlog10op><code>llvm.intr.log10</code> (::mlir::LLVM::Log10Op)&nbsp;<a class=headline-hash href=#llvmintrlog10-mlirllvmlog10op>¶</a></h3><h4 id=operands-49>Operands:&nbsp;<a class=headline-hash href=#operands-49>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-48>Results:&nbsp;<a class=headline-hash href=#results-48>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrlog2-mlirllvmlog2op><code>llvm.intr.log2</code> (::mlir::LLVM::Log2Op)&nbsp;<a class=headline-hash href=#llvmintrlog2-mlirllvmlog2op>¶</a></h3><h4 id=operands-50>Operands:&nbsp;<a class=headline-hash href=#operands-50>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-49>Results:&nbsp;<a class=headline-hash href=#results-49>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrlog-mlirllvmlogop><code>llvm.intr.log</code> (::mlir::LLVM::LogOp)&nbsp;<a class=headline-hash href=#llvmintrlog-mlirllvmlogop>¶</a></h3><h4 id=operands-51>Operands:&nbsp;<a class=headline-hash href=#operands-51>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-50>Results:&nbsp;<a class=headline-hash href=#results-50>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrmaskedload-mlirllvmmaskedloadop><code>llvm.intr.masked.load</code> (::mlir::LLVM::MaskedLoadOp)&nbsp;<a class=headline-hash href=#llvmintrmaskedload-mlirllvmmaskedloadop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.intr.masked.load` operands attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>alignment</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-52>Operands:&nbsp;<a class=headline-hash href=#operands-52>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>data</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>mask</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>pass_thru</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-51>Results:&nbsp;<a class=headline-hash href=#results-51>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrmaskedstore-mlirllvmmaskedstoreop><code>llvm.intr.masked.store</code> (::mlir::LLVM::MaskedStoreOp)&nbsp;<a class=headline-hash href=#llvmintrmaskedstore-mlirllvmmaskedstoreop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.intr.masked.store` $value `,` $data `,` $mask attr-dict `:` type($value) `,` type($mask) `into` type($data)
</code></pre><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>alignment</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-53>Operands:&nbsp;<a class=headline-hash href=#operands-53>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>data</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>mask</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrmatrixcolumnmajorload-mlirllvmmatrixcolumnmajorloadop><code>llvm.intr.matrix.column.major.load</code> (::mlir::LLVM::MatrixColumnMajorLoadOp)&nbsp;<a class=headline-hash href=#llvmintrmatrixcolumnmajorload-mlirllvmmatrixcolumnmajorloadop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.intr.matrix.column.major.load` $data `,` `&lt;` `stride` `=` $stride `&gt;` attr-dict`:` type($res) `from` type($data) `stride` type($stride)
</code></pre><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>isVolatile</code></td><td align=center>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td align=center><code>rows</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>columns</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-54>Operands:&nbsp;<a class=headline-hash href=#operands-54>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>data</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>stride</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-52>Results:&nbsp;<a class=headline-hash href=#results-52>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrmatrixcolumnmajorstore-mlirllvmmatrixcolumnmajorstoreop><code>llvm.intr.matrix.column.major.store</code> (::mlir::LLVM::MatrixColumnMajorStoreOp)&nbsp;<a class=headline-hash href=#llvmintrmatrixcolumnmajorstore-mlirllvmmatrixcolumnmajorstoreop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.intr.matrix.column.major.store` $matrix `,` $data `,` `&lt;` `stride` `=` $stride `&gt;` attr-dict`:` type($matrix) `to` type($data) `stride` type($stride)
</code></pre><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>isVolatile</code></td><td align=center>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td align=center><code>rows</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>columns</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-55>Operands:&nbsp;<a class=headline-hash href=#operands-55>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>matrix</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>data</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>stride</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrmatrixmultiply-mlirllvmmatrixmultiplyop><code>llvm.intr.matrix.multiply</code> (::mlir::LLVM::MatrixMultiplyOp)&nbsp;<a class=headline-hash href=#llvmintrmatrixmultiply-mlirllvmmatrixmultiplyop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.intr.matrix.multiply` $lhs `,` $rhs attr-dict `:` `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($res)
</code></pre><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs_rows</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>lhs_columns</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>rhs_columns</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-56>Operands:&nbsp;<a class=headline-hash href=#operands-56>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>rhs</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-53>Results:&nbsp;<a class=headline-hash href=#results-53>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrmatrixtranspose-mlirllvmmatrixtransposeop><code>llvm.intr.matrix.transpose</code> (::mlir::LLVM::MatrixTransposeOp)&nbsp;<a class=headline-hash href=#llvmintrmatrixtranspose-mlirllvmmatrixtransposeop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.intr.matrix.transpose` $matrix attr-dict `:` type($matrix) `into` type($res)
</code></pre><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>rows</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>columns</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-57>Operands:&nbsp;<a class=headline-hash href=#operands-57>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>matrix</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-54>Results:&nbsp;<a class=headline-hash href=#results-54>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrmaxnum-mlirllvmmaxnumop><code>llvm.intr.maxnum</code> (::mlir::LLVM::MaxNumOp)&nbsp;<a class=headline-hash href=#llvmintrmaxnum-mlirllvmmaxnumop>¶</a></h3><h4 id=operands-58>Operands:&nbsp;<a class=headline-hash href=#operands-58>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>a</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>b</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-55>Results:&nbsp;<a class=headline-hash href=#results-55>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrmemcpyinline-mlirllvmmemcpyinlineop><code>llvm.intr.memcpy.inline</code> (::mlir::LLVM::MemcpyInlineOp)&nbsp;<a class=headline-hash href=#llvmintrmemcpyinline-mlirllvmmemcpyinlineop>¶</a></h3><h4 id=operands-59>Operands:&nbsp;<a class=headline-hash href=#operands-59>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dst</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>src</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>len</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>isVolatile</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrmemcpy-mlirllvmmemcpyop><code>llvm.intr.memcpy</code> (::mlir::LLVM::MemcpyOp)&nbsp;<a class=headline-hash href=#llvmintrmemcpy-mlirllvmmemcpyop>¶</a></h3><h4 id=operands-60>Operands:&nbsp;<a class=headline-hash href=#operands-60>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dst</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>src</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>len</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>isVolatile</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrminnum-mlirllvmminnumop><code>llvm.intr.minnum</code> (::mlir::LLVM::MinNumOp)&nbsp;<a class=headline-hash href=#llvmintrminnum-mlirllvmminnumop>¶</a></h3><h4 id=operands-61>Operands:&nbsp;<a class=headline-hash href=#operands-61>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>a</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>b</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-56>Results:&nbsp;<a class=headline-hash href=#results-56>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmmul-mlirllvmmulop><code>llvm.mul</code> (::mlir::LLVM::MulOp)&nbsp;<a class=headline-hash href=#llvmmul-mlirllvmmulop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.mul` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-62>Operands:&nbsp;<a class=headline-hash href=#operands-62>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr><tr><td align=center><code>rhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-57>Results:&nbsp;<a class=headline-hash href=#results-57>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmmlirnull-mlirllvmnullop><code>llvm.mlir.null</code> (::mlir::LLVM::NullOp)&nbsp;<a class=headline-hash href=#llvmmlirnull-mlirllvmnullop>¶</a></h3><p>Defines a value containing a null pointer to LLVM type.</p><p>Syntax:</p><pre><code>operation ::= `llvm.mlir.null` attr-dict `:` type($res)
</code></pre><p>Unlike LLVM IR, MLIR does not have first-class null pointers. They must be
explicitly created as SSA values using <code>llvm.mlir.null</code>. This operation has
no operands or attributes, and returns a null value of a wrapped LLVM IR
pointer type.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Null pointer to i8.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>null <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>

<span class=c>// Null pointer to a function with signature void().
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>null <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>(</span><span class=p>)</span><span class=p>&gt;</span><span class=p>&gt;</span>
</code></pre></div><h4 id=results-58>Results:&nbsp;<a class=headline-hash href=#results-58>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmor-mlirllvmorop><code>llvm.or</code> (::mlir::LLVM::OrOp)&nbsp;<a class=headline-hash href=#llvmor-mlirllvmorop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.or` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-63>Operands:&nbsp;<a class=headline-hash href=#operands-63>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr><tr><td align=center><code>rhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-59>Results:&nbsp;<a class=headline-hash href=#results-59>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmintrpow-mlirllvmpowop><code>llvm.intr.pow</code> (::mlir::LLVM::PowOp)&nbsp;<a class=headline-hash href=#llvmintrpow-mlirllvmpowop>¶</a></h3><h4 id=operands-64>Operands:&nbsp;<a class=headline-hash href=#operands-64>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>a</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>b</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-60>Results:&nbsp;<a class=headline-hash href=#results-60>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrprefetch-mlirllvmprefetch><code>llvm.intr.prefetch</code> (::mlir::LLVM::Prefetch)&nbsp;<a class=headline-hash href=#llvmintrprefetch-mlirllvmprefetch>¶</a></h3><h4 id=operands-65>Operands:&nbsp;<a class=headline-hash href=#operands-65>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>addr</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>rw</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>hint</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>cache</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmptrtoint-mlirllvmptrtointop><code>llvm.ptrtoint</code> (::mlir::LLVM::PtrToIntOp)&nbsp;<a class=headline-hash href=#llvmptrtoint-mlirllvmptrtointop>¶</a></h3><h4 id=operands-66>Operands:&nbsp;<a class=headline-hash href=#operands-66>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>LLVM pointer type or LLVM vector of LLVM pointer type</td></tr></tbody></table><h4 id=results-61>Results:&nbsp;<a class=headline-hash href=#results-61>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmresume-mlirllvmresumeop><code>llvm.resume</code> (::mlir::LLVM::ResumeOp)&nbsp;<a class=headline-hash href=#llvmresume-mlirllvmresumeop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.resume` $value attr-dict `:` type($value)
</code></pre><h4 id=operands-67>Operands:&nbsp;<a class=headline-hash href=#operands-67>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmreturn-mlirllvmreturnop><code>llvm.return</code> (::mlir::LLVM::ReturnOp)&nbsp;<a class=headline-hash href=#llvmreturn-mlirllvmreturnop>¶</a></h3><h4 id=operands-68>Operands:&nbsp;<a class=headline-hash href=#operands-68>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>args</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrsaddwithoverflow-mlirllvmsaddwithoverflowop><code>llvm.intr.sadd.with.overflow</code> (::mlir::LLVM::SAddWithOverflowOp)&nbsp;<a class=headline-hash href=#llvmintrsaddwithoverflow-mlirllvmsaddwithoverflowop>¶</a></h3><h4 id=operands-69>Operands:&nbsp;<a class=headline-hash href=#operands-69>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-62>Results:&nbsp;<a class=headline-hash href=#results-62>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmsdiv-mlirllvmsdivop><code>llvm.sdiv</code> (::mlir::LLVM::SDivOp)&nbsp;<a class=headline-hash href=#llvmsdiv-mlirllvmsdivop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.sdiv` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-70>Operands:&nbsp;<a class=headline-hash href=#operands-70>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr><tr><td align=center><code>rhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-63>Results:&nbsp;<a class=headline-hash href=#results-63>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmsext-mlirllvmsextop><code>llvm.sext</code> (::mlir::LLVM::SExtOp)&nbsp;<a class=headline-hash href=#llvmsext-mlirllvmsextop>¶</a></h3><h4 id=operands-71>Operands:&nbsp;<a class=headline-hash href=#operands-71>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-64>Results:&nbsp;<a class=headline-hash href=#results-64>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmsitofp-mlirllvmsitofpop><code>llvm.sitofp</code> (::mlir::LLVM::SIToFPOp)&nbsp;<a class=headline-hash href=#llvmsitofp-mlirllvmsitofpop>¶</a></h3><h4 id=operands-72>Operands:&nbsp;<a class=headline-hash href=#operands-72>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-65>Results:&nbsp;<a class=headline-hash href=#results-65>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmintrsmax-mlirllvmsmaxop><code>llvm.intr.smax</code> (::mlir::LLVM::SMaxOp)&nbsp;<a class=headline-hash href=#llvmintrsmax-mlirllvmsmaxop>¶</a></h3><h4 id=operands-73>Operands:&nbsp;<a class=headline-hash href=#operands-73>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>a</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>b</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-66>Results:&nbsp;<a class=headline-hash href=#results-66>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrsmin-mlirllvmsminop><code>llvm.intr.smin</code> (::mlir::LLVM::SMinOp)&nbsp;<a class=headline-hash href=#llvmintrsmin-mlirllvmsminop>¶</a></h3><h4 id=operands-74>Operands:&nbsp;<a class=headline-hash href=#operands-74>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>a</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>b</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-67>Results:&nbsp;<a class=headline-hash href=#results-67>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrsmulwithoverflow-mlirllvmsmulwithoverflowop><code>llvm.intr.smul.with.overflow</code> (::mlir::LLVM::SMulWithOverflowOp)&nbsp;<a class=headline-hash href=#llvmintrsmulwithoverflow-mlirllvmsmulwithoverflowop>¶</a></h3><h4 id=operands-75>Operands:&nbsp;<a class=headline-hash href=#operands-75>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-68>Results:&nbsp;<a class=headline-hash href=#results-68>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmsrem-mlirllvmsremop><code>llvm.srem</code> (::mlir::LLVM::SRemOp)&nbsp;<a class=headline-hash href=#llvmsrem-mlirllvmsremop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.srem` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-76>Operands:&nbsp;<a class=headline-hash href=#operands-76>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr><tr><td align=center><code>rhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-69>Results:&nbsp;<a class=headline-hash href=#results-69>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmintrssubwithoverflow-mlirllvmssubwithoverflowop><code>llvm.intr.ssub.with.overflow</code> (::mlir::LLVM::SSubWithOverflowOp)&nbsp;<a class=headline-hash href=#llvmintrssubwithoverflow-mlirllvmssubwithoverflowop>¶</a></h3><h4 id=operands-77>Operands:&nbsp;<a class=headline-hash href=#operands-77>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-70>Results:&nbsp;<a class=headline-hash href=#results-70>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmselect-mlirllvmselectop><code>llvm.select</code> (::mlir::LLVM::SelectOp)&nbsp;<a class=headline-hash href=#llvmselect-mlirllvmselectop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.select` operands attr-dict `:` type($condition) `,` type($res)
</code></pre><h4 id=operands-78>Operands:&nbsp;<a class=headline-hash href=#operands-78>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>condition</code></td><td>LLVM 1-bit integer type or LLVM vector of LLVM 1-bit integer type</td></tr><tr><td align=center><code>trueValue</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>falseValue</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-71>Results:&nbsp;<a class=headline-hash href=#results-71>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmshl-mlirllvmshlop><code>llvm.shl</code> (::mlir::LLVM::ShlOp)&nbsp;<a class=headline-hash href=#llvmshl-mlirllvmshlop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.shl` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-79>Operands:&nbsp;<a class=headline-hash href=#operands-79>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr><tr><td align=center><code>rhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-72>Results:&nbsp;<a class=headline-hash href=#results-72>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmshufflevector-mlirllvmshufflevectorop><code>llvm.shufflevector</code> (::mlir::LLVM::ShuffleVectorOp)&nbsp;<a class=headline-hash href=#llvmshufflevector-mlirllvmshufflevectorop>¶</a></h3><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>mask</code></td><td align=center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h4 id=operands-80>Operands:&nbsp;<a class=headline-hash href=#operands-80>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>v1</code></td><td>LLVM vector type</td></tr><tr><td align=center><code>v2</code></td><td>LLVM vector type</td></tr></tbody></table><h4 id=results-73>Results:&nbsp;<a class=headline-hash href=#results-73>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM vector type</td></tr></tbody></table><h3 id=llvmintrsin-mlirllvmsinop><code>llvm.intr.sin</code> (::mlir::LLVM::SinOp)&nbsp;<a class=headline-hash href=#llvmintrsin-mlirllvmsinop>¶</a></h3><h4 id=operands-81>Operands:&nbsp;<a class=headline-hash href=#operands-81>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-74>Results:&nbsp;<a class=headline-hash href=#results-74>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrsqrt-mlirllvmsqrtop><code>llvm.intr.sqrt</code> (::mlir::LLVM::SqrtOp)&nbsp;<a class=headline-hash href=#llvmintrsqrt-mlirllvmsqrtop>¶</a></h3><h4 id=operands-82>Operands:&nbsp;<a class=headline-hash href=#operands-82>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>in</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-75>Results:&nbsp;<a class=headline-hash href=#results-75>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmstore-mlirllvmstoreop><code>llvm.store</code> (::mlir::LLVM::StoreOp)&nbsp;<a class=headline-hash href=#llvmstore-mlirllvmstoreop>¶</a></h3><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>alignment</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td align=center><code>volatile_</code></td><td align=center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td align=center><code>nontemporal</code></td><td align=center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-83>Operands:&nbsp;<a class=headline-hash href=#operands-83>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>LLVM type with size</td></tr><tr><td align=center><code>addr</code></td><td>LLVM pointer to LLVM type with size</td></tr></tbody></table><h3 id=llvmsub-mlirllvmsubop><code>llvm.sub</code> (::mlir::LLVM::SubOp)&nbsp;<a class=headline-hash href=#llvmsub-mlirllvmsubop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.sub` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-84>Operands:&nbsp;<a class=headline-hash href=#operands-84>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr><tr><td align=center><code>rhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-76>Results:&nbsp;<a class=headline-hash href=#results-76>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmswitch-mlirllvmswitchop><code>llvm.switch</code> (::mlir::LLVM::SwitchOp)&nbsp;<a class=headline-hash href=#llvmswitch-mlirllvmswitchop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.switch` $value `,`
              $defaultDestination (`(` $defaultOperands^ `:` type($defaultOperands) `)`)?
              `[` `\n` custom&lt;SwitchOpCases&gt;($case_values, $caseDestinations,
              $caseOperands, type($caseOperands),
              $case_operand_offsets) `]`
              attr-dict
</code></pre><h4 id=attributes-26>Attributes:&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>case_values</code></td><td align=center>::mlir::ElementsAttr</td><td>constant vector/tensor attribute</td></tr><tr><td align=center><code>case_operand_offsets</code></td><td align=center>::mlir::ElementsAttr</td><td>constant vector/tensor attribute</td></tr><tr><td align=center><code>branch_weights</code></td><td align=center>::mlir::ElementsAttr</td><td>constant vector/tensor attribute</td></tr></tbody></table><h4 id=operands-85>Operands:&nbsp;<a class=headline-hash href=#operands-85>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>LLVM 32-bit integer type</td></tr><tr><td align=center><code>defaultOperands</code></td><td>any type</td></tr><tr><td align=center><code>caseOperands</code></td><td>any type</td></tr></tbody></table><h4 id=successors-3>Successors:&nbsp;<a class=headline-hash href=#successors-3>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>defaultDestination</code></td><td>any successor</td></tr><tr><td align=center><code>caseDestinations</code></td><td>any successor</td></tr></tbody></table><h3 id=llvmtrunc-mlirllvmtruncop><code>llvm.trunc</code> (::mlir::LLVM::TruncOp)&nbsp;<a class=headline-hash href=#llvmtrunc-mlirllvmtruncop>¶</a></h3><h4 id=operands-86>Operands:&nbsp;<a class=headline-hash href=#operands-86>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-77>Results:&nbsp;<a class=headline-hash href=#results-77>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmintruaddwithoverflow-mlirllvmuaddwithoverflowop><code>llvm.intr.uadd.with.overflow</code> (::mlir::LLVM::UAddWithOverflowOp)&nbsp;<a class=headline-hash href=#llvmintruaddwithoverflow-mlirllvmuaddwithoverflowop>¶</a></h3><h4 id=operands-87>Operands:&nbsp;<a class=headline-hash href=#operands-87>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-78>Results:&nbsp;<a class=headline-hash href=#results-78>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmudiv-mlirllvmudivop><code>llvm.udiv</code> (::mlir::LLVM::UDivOp)&nbsp;<a class=headline-hash href=#llvmudiv-mlirllvmudivop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.udiv` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-88>Operands:&nbsp;<a class=headline-hash href=#operands-88>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr><tr><td align=center><code>rhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-79>Results:&nbsp;<a class=headline-hash href=#results-79>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmuitofp-mlirllvmuitofpop><code>llvm.uitofp</code> (::mlir::LLVM::UIToFPOp)&nbsp;<a class=headline-hash href=#llvmuitofp-mlirllvmuitofpop>¶</a></h3><h4 id=operands-89>Operands:&nbsp;<a class=headline-hash href=#operands-89>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-80>Results:&nbsp;<a class=headline-hash href=#results-80>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>floating point LLVM type or LLVM vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmintrumulwithoverflow-mlirllvmumulwithoverflowop><code>llvm.intr.umul.with.overflow</code> (::mlir::LLVM::UMulWithOverflowOp)&nbsp;<a class=headline-hash href=#llvmintrumulwithoverflow-mlirllvmumulwithoverflowop>¶</a></h3><h4 id=operands-90>Operands:&nbsp;<a class=headline-hash href=#operands-90>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-81>Results:&nbsp;<a class=headline-hash href=#results-81>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmurem-mlirllvmuremop><code>llvm.urem</code> (::mlir::LLVM::URemOp)&nbsp;<a class=headline-hash href=#llvmurem-mlirllvmuremop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.urem` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-91>Operands:&nbsp;<a class=headline-hash href=#operands-91>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr><tr><td align=center><code>rhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-82>Results:&nbsp;<a class=headline-hash href=#results-82>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmintrusubwithoverflow-mlirllvmusubwithoverflowop><code>llvm.intr.usub.with.overflow</code> (::mlir::LLVM::USubWithOverflowOp)&nbsp;<a class=headline-hash href=#llvmintrusubwithoverflow-mlirllvmusubwithoverflowop>¶</a></h3><h4 id=operands-92>Operands:&nbsp;<a class=headline-hash href=#operands-92>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-83>Results:&nbsp;<a class=headline-hash href=#results-83>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmmlirundef-mlirllvmundefop><code>llvm.mlir.undef</code> (::mlir::LLVM::UndefOp)&nbsp;<a class=headline-hash href=#llvmmlirundef-mlirllvmundefop>¶</a></h3><p>Creates an undefined value of LLVM dialect type.</p><p>Syntax:</p><pre><code>operation ::= `llvm.mlir.undef` attr-dict `:` type($res)
</code></pre><p>Unlike LLVM IR, MLIR does not have first-class undefined values. Such values
must be created as SSA values using <code>llvm.mlir.undef</code>. This operation has no
operands or attributes. It creates an undefined value of the specified LLVM
IR dialect type wrapping an LLVM IR structure type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Create a structure with a 32-bit integer followed by a float.
</span><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>undef <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=p>(</span><span class=k>i32</span><span class=p>,</span> float<span class=p>)</span><span class=p>&gt;</span>
</code></pre></div><h4 id=results-84>Results:&nbsp;<a class=headline-hash href=#results-84>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmunreachable-mlirllvmunreachableop><code>llvm.unreachable</code> (::mlir::LLVM::UnreachableOp)&nbsp;<a class=headline-hash href=#llvmunreachable-mlirllvmunreachableop>¶</a></h3><h3 id=llvmxor-mlirllvmxorop><code>llvm.xor</code> (::mlir::LLVM::XOrOp)&nbsp;<a class=headline-hash href=#llvmxor-mlirllvmxorop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.xor` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><h4 id=operands-93>Operands:&nbsp;<a class=headline-hash href=#operands-93>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr><tr><td align=center><code>rhs</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-85>Results:&nbsp;<a class=headline-hash href=#results-85>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmzext-mlirllvmzextop><code>llvm.zext</code> (::mlir::LLVM::ZExtOp)&nbsp;<a class=headline-hash href=#llvmzext-mlirllvmzextop>¶</a></h3><h4 id=operands-94>Operands:&nbsp;<a class=headline-hash href=#operands-94>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>arg</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h4 id=results-86>Results:&nbsp;<a class=headline-hash href=#results-86>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM integer type or LLVM vector of LLVM integer type</td></tr></tbody></table><h3 id=llvmintrmaskedcompressstore-mlirllvmmasked_compressstore><code>llvm.intr.masked.compressstore</code> (::mlir::LLVM::masked_compressstore)&nbsp;<a class=headline-hash href=#llvmintrmaskedcompressstore-mlirllvmmasked_compressstore>¶</a></h3><h4 id=operands-95>Operands:&nbsp;<a class=headline-hash href=#operands-95>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrmaskedexpandload-mlirllvmmasked_expandload><code>llvm.intr.masked.expandload</code> (::mlir::LLVM::masked_expandload)&nbsp;<a class=headline-hash href=#llvmintrmaskedexpandload-mlirllvmmasked_expandload>¶</a></h3><h4 id=operands-96>Operands:&nbsp;<a class=headline-hash href=#operands-96>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-87>Results:&nbsp;<a class=headline-hash href=#results-87>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrmaskedgather-mlirllvmmasked_gather><code>llvm.intr.masked.gather</code> (::mlir::LLVM::masked_gather)&nbsp;<a class=headline-hash href=#llvmintrmaskedgather-mlirllvmmasked_gather>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.intr.masked.gather` operands attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=attributes-27>Attributes:&nbsp;<a class=headline-hash href=#attributes-27>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>alignment</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-97>Operands:&nbsp;<a class=headline-hash href=#operands-97>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>ptrs</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>mask</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>pass_thru</code></td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-88>Results:&nbsp;<a class=headline-hash href=#results-88>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrmaskedscatter-mlirllvmmasked_scatter><code>llvm.intr.masked.scatter</code> (::mlir::LLVM::masked_scatter)&nbsp;<a class=headline-hash href=#llvmintrmaskedscatter-mlirllvmmasked_scatter>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `llvm.intr.masked.scatter` $value `,` $ptrs `,` $mask attr-dict `:` type($value) `,` type($mask) `into` type($ptrs)
</code></pre><h4 id=attributes-28>Attributes:&nbsp;<a class=headline-hash href=#attributes-28>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>alignment</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-98>Operands:&nbsp;<a class=headline-hash href=#operands-98>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>ptrs</code></td><td>LLVM dialect type</td></tr><tr><td align=center><code>mask</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrvectorreduceadd-mlirllvmvector_reduce_add><code>llvm.intr.vector.reduce.add</code> (::mlir::LLVM::vector_reduce_add)&nbsp;<a class=headline-hash href=#llvmintrvectorreduceadd-mlirllvmvector_reduce_add>¶</a></h3><h4 id=operands-99>Operands:&nbsp;<a class=headline-hash href=#operands-99>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-89>Results:&nbsp;<a class=headline-hash href=#results-89>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrvectorreduceand-mlirllvmvector_reduce_and><code>llvm.intr.vector.reduce.and</code> (::mlir::LLVM::vector_reduce_and)&nbsp;<a class=headline-hash href=#llvmintrvectorreduceand-mlirllvmvector_reduce_and>¶</a></h3><h4 id=operands-100>Operands:&nbsp;<a class=headline-hash href=#operands-100>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-90>Results:&nbsp;<a class=headline-hash href=#results-90>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrvectorreducefadd-mlirllvmvector_reduce_fadd><code>llvm.intr.vector.reduce.fadd</code> (::mlir::LLVM::vector_reduce_fadd)&nbsp;<a class=headline-hash href=#llvmintrvectorreducefadd-mlirllvmvector_reduce_fadd>¶</a></h3><h4 id=attributes-29>Attributes:&nbsp;<a class=headline-hash href=#attributes-29>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>reassoc</code></td><td align=center>::mlir::BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=operands-101>Operands:&nbsp;<a class=headline-hash href=#operands-101>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-91>Results:&nbsp;<a class=headline-hash href=#results-91>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrvectorreducefmax-mlirllvmvector_reduce_fmax><code>llvm.intr.vector.reduce.fmax</code> (::mlir::LLVM::vector_reduce_fmax)&nbsp;<a class=headline-hash href=#llvmintrvectorreducefmax-mlirllvmvector_reduce_fmax>¶</a></h3><h4 id=operands-102>Operands:&nbsp;<a class=headline-hash href=#operands-102>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-92>Results:&nbsp;<a class=headline-hash href=#results-92>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrvectorreducefmin-mlirllvmvector_reduce_fmin><code>llvm.intr.vector.reduce.fmin</code> (::mlir::LLVM::vector_reduce_fmin)&nbsp;<a class=headline-hash href=#llvmintrvectorreducefmin-mlirllvmvector_reduce_fmin>¶</a></h3><h4 id=operands-103>Operands:&nbsp;<a class=headline-hash href=#operands-103>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-93>Results:&nbsp;<a class=headline-hash href=#results-93>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrvectorreducefmul-mlirllvmvector_reduce_fmul><code>llvm.intr.vector.reduce.fmul</code> (::mlir::LLVM::vector_reduce_fmul)&nbsp;<a class=headline-hash href=#llvmintrvectorreducefmul-mlirllvmvector_reduce_fmul>¶</a></h3><h4 id=attributes-30>Attributes:&nbsp;<a class=headline-hash href=#attributes-30>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>reassoc</code></td><td align=center>::mlir::BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=operands-104>Operands:&nbsp;<a class=headline-hash href=#operands-104>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-94>Results:&nbsp;<a class=headline-hash href=#results-94>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrvectorreducemul-mlirllvmvector_reduce_mul><code>llvm.intr.vector.reduce.mul</code> (::mlir::LLVM::vector_reduce_mul)&nbsp;<a class=headline-hash href=#llvmintrvectorreducemul-mlirllvmvector_reduce_mul>¶</a></h3><h4 id=operands-105>Operands:&nbsp;<a class=headline-hash href=#operands-105>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-95>Results:&nbsp;<a class=headline-hash href=#results-95>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrvectorreduceor-mlirllvmvector_reduce_or><code>llvm.intr.vector.reduce.or</code> (::mlir::LLVM::vector_reduce_or)&nbsp;<a class=headline-hash href=#llvmintrvectorreduceor-mlirllvmvector_reduce_or>¶</a></h3><h4 id=operands-106>Operands:&nbsp;<a class=headline-hash href=#operands-106>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-96>Results:&nbsp;<a class=headline-hash href=#results-96>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrvectorreducesmax-mlirllvmvector_reduce_smax><code>llvm.intr.vector.reduce.smax</code> (::mlir::LLVM::vector_reduce_smax)&nbsp;<a class=headline-hash href=#llvmintrvectorreducesmax-mlirllvmvector_reduce_smax>¶</a></h3><h4 id=operands-107>Operands:&nbsp;<a class=headline-hash href=#operands-107>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-97>Results:&nbsp;<a class=headline-hash href=#results-97>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrvectorreducesmin-mlirllvmvector_reduce_smin><code>llvm.intr.vector.reduce.smin</code> (::mlir::LLVM::vector_reduce_smin)&nbsp;<a class=headline-hash href=#llvmintrvectorreducesmin-mlirllvmvector_reduce_smin>¶</a></h3><h4 id=operands-108>Operands:&nbsp;<a class=headline-hash href=#operands-108>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-98>Results:&nbsp;<a class=headline-hash href=#results-98>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrvectorreduceumax-mlirllvmvector_reduce_umax><code>llvm.intr.vector.reduce.umax</code> (::mlir::LLVM::vector_reduce_umax)&nbsp;<a class=headline-hash href=#llvmintrvectorreduceumax-mlirllvmvector_reduce_umax>¶</a></h3><h4 id=operands-109>Operands:&nbsp;<a class=headline-hash href=#operands-109>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-99>Results:&nbsp;<a class=headline-hash href=#results-99>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrvectorreduceumin-mlirllvmvector_reduce_umin><code>llvm.intr.vector.reduce.umin</code> (::mlir::LLVM::vector_reduce_umin)&nbsp;<a class=headline-hash href=#llvmintrvectorreduceumin-mlirllvmvector_reduce_umin>¶</a></h3><h4 id=operands-110>Operands:&nbsp;<a class=headline-hash href=#operands-110>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-100>Results:&nbsp;<a class=headline-hash href=#results-100>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><h3 id=llvmintrvectorreducexor-mlirllvmvector_reduce_xor><code>llvm.intr.vector.reduce.xor</code> (::mlir::LLVM::vector_reduce_xor)&nbsp;<a class=headline-hash href=#llvmintrvectorreducexor-mlirllvmvector_reduce_xor>¶</a></h3><h4 id=operands-111>Operands:&nbsp;<a class=headline-hash href=#operands-111>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>LLVM dialect type</td></tr></tbody></table><h4 id=results-101>Results:&nbsp;<a class=headline-hash href=#results-101>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>res</code></td><td>LLVM dialect type</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/Linalg/ title="'linalg' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'linalg' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/LLVMArmNeon/ title="'llvm_arm_neon' Dialect">Next - 'llvm_arm_neon' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/Bufferization/>Bufferization on MLIR</a></li><li><a href=/docs/LLVMDialectMemRefConvention/>Built-in Function and MemRef Calling Convention</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Builtin/></a></li><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/AVX512/>'avx512' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li class=active><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/LLVMArmNeon/>'llvm_arm_neon' Dialect</a></li><li><a href=/docs/Dialects/LLVMArmSve/>'llvm_arm_sve' Dialect</a></li><li><a href=/docs/Dialects/LLVMAVX512/>'llvm_avx512' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li></ul></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/DefiningAttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>